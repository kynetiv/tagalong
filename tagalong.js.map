{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap 008285fd64a423025270","webpack:///./src/main.js","webpack:///./~/document-register-element/build/document-register-element.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/render.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./src/interpolate.js","webpack:///./src/transform.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Template","render","window","tagalong","createRenderer","create","e","t","n","r","rt","length","dt","it","nt","b","ot","st","j","querySelectorAll","w","getAttribute","nodeName","toUpperCase","S","y","v","d","ut","indexOf","at","currentTarget","attrChange","attrName","i","target","Q","attributeChangedCallback","a","prevValue","l","newValue","ft","X","push","lt","K","removeEventListener","h","detail","o","s","B","pt","ct","this","q","G","ht","D","et","observe","z","J","setAttribute","Z","addEventListener","createdCallback","created","F","E","contains","splice","tt","Y","Math","random","u","f","g","documentElement","x","prototype","T","hasOwnProperty","N","isPrototypeOf","C","defineProperty","k","getOwnPropertyDescriptor","L","getOwnPropertyNames","A","getPrototypeOf","O","setPrototypeOf","M","__proto__","_","vt","P","MutationObserver","WebKitMutationObserver","H","HTMLElement","Element","Node","nodeType","I","cloneNode","R","removeAttribute","U","createElement","attributes","characterData","attributeOldValue","W","V","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","$","value","CustomEvent","bubbles","dispatchEvent","hasAttribute","propertyName","name","className","type","addedNodes","removedNodes","attributeName","oldValue","childList","subtree","shift","apply","arguments","toLowerCase","innerHTMLHelper","Error","test","concat","document","Object","property","evaluate","RENDER","DATA_ATTR","registerElement","attachedCallback","console","log","update","attr","previous","expr","data","invalidate","read","write","enumerable","get","set","identity","arrow","expression","fn","evaluator","is","parse","symbol","Date","now","match","Function","join","ARROW_PATTERN","isArrow","String","parseArrow","args","body","createRenderFunction","root","context","selector","querySelector","incremental","patch","bind","calls","child","firstChild","nextSibling","TEXT_NODE","createTextRenderer","ELEMENT_NODE","createElementRenderer","forEach","node","nodeValue","interpolate","isTemplate","text","defined","T_SKIP","noop","isVoid","isElementVoid","attrMap","getAttributeMap","condition","T_IF","xp","T_ELSE","ifSibling","getPreviousSibling","not","renderChildren","textExpression","T_TEXT","getText","attrs","interpolateAttributes","elementVoid","elementOpen","elementClose","eachExpression","T_EACH","forEachExpression","T_FOREACH","withExpression","T_WITH","T_AS","renderEach","renderWith","symbolSetter","values","map","T_NS","substr","CONTROL_ATTRS","getter","transform","style","key","previousSibling","matches","VOID_ELEMENTS","iterate","INDEX","each","Array","isArray","split","undefined","process","TreeWalker","stack_","currentNode","Context","prevContext","walker","doc","ownerDocument","nsStack_","notifications","nodesCreated","deleted","nodesDeleted","NodeData","createMap","attrsArr","newAttrs","keyMap","keyMapValid","lastVisitedChild","getCurrentParent","parentNode","pop","getCurrentNamespace","enterNamespace","namespace","exitNamespace","markCreated","markDeleted","notifyChanges","enterContext","restoreContext","getContext","has","initData","getData","symbols","default","placeholder","applyAttr","el","applyProp","applyStyle","cssText","elStyle","prop","applyAttributeTyped","updateAttribute","mutator","SVG_NS","enterTag","tag","exitTag","getNamespaceForTag","statics","createElementNS","createNode","createTextNode","createKeyMap","children","count","getKeyMap","getChild","parent","registerChild","env","NODE_ENV","assertKeyedTagMatches","alignWithDOM","matchingNode","existingNode","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","enterNode","exitNode","markVisited","assertNoUnclosedTags","openElement","openTags","ATTRIBUTES_OFFSET","argsBuilder","inAttributes","assertNotInAttributes","assertInAttributes","assertPlaceholderKeySpecified","assertCloseMatchesOpenTag","closingNode","setInAttributes","setNotInAttributes","var_args","attrsChanged","elementOpenStart","elementOpenEnd","elementPlaceholder","formatted","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","clearTimeout","Item","fun","array","nextTick","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","template","that","replace","pattern","formatStyle","obj","keys","reformatCamelCase","str","char","formatClassName","filter"],"mappings":"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","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t\n\tvar Template = __webpack_require__(2);\n\tvar render = __webpack_require__(6);\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: render.create,\n\t  render: render.render\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*! (C) WebReflection Mit Style License */\n\t(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(3);\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar createRenderer = __webpack_require__(6).create;\n\t\n\tvar RENDER = '__render';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        console.log('attached!', this);\n\t        this.update();\n\t      }},\n\t\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      render: {value: function(data) {\n\t        if (!arguments.length) data = this.data;\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t        this.render();\n\t      }},\n\t\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, value) {\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      return read ? read.call(this, value) : value;\n\t    },\n\t\n\t    set: function(v) {\n\t      if (v !== value) {\n\t        var previous = value;\n\t        return value = write.call(this, v, previous);\n\t      }\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrow = __webpack_require__(5);\n\t\n\tvar evaluate = function(expression, data) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, data);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (arrow.is(expression)) {\n\t    return arrow.parse(expression);\n\t  }\n\t\n\t  var symbol = 'd' + Date.now();\n\t  // '.' is just the identity function\n\t  if (expression.match(/^\\s*\\.\\s*$/)) {\n\t    return identity;\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    '  with (this) {',\n\t    '    with (', symbol, ') {',\n\t    '      return (', expression, ');',\n\t    '    } ',\n\t    '  } ',\n\t    '} catch (error) { }'\n\t  ].join('\\n'));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator,\n\t};\n\t\n\tfunction identity(d) {\n\t  return d;\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = match[4] || match[5];\n\t  return new Function(args, [\n\t    'try {',\n\t    '  with (this) {',\n\t    '    return (', body, ');',\n\t    '  }',\n\t    '} catch (error) { }'\n\t  ].join('\\n'));\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar incremental = __webpack_require__(7);\n\tvar xp = __webpack_require__(4);\n\tvar interpolate = __webpack_require__(9);\n\tvar transform = __webpack_require__(10);\n\t\n\t// our attribute namespace\n\tvar T_NS = 't-';\n\t\n\tvar T_AS = T_NS + 'as';\n\tvar T_SKIP = T_NS + 'skip';\n\tvar T_IF = T_NS + 'if';\n\tvar T_ELSE = T_NS + 'else';\n\tvar T_EACH = T_NS + 'each';\n\tvar T_FOREACH = T_NS + 'foreach';\n\tvar T_WITH = T_NS + 'with';\n\tvar T_TEXT = T_NS + 'text';\n\t\n\tvar CONTROL_ATTRS = [\n\t  'if',\n\t  'else',\n\t  'each',\n\t  'foreach',\n\t  'with',\n\t  'text',\n\t  'as',\n\t  'skip'\n\t];\n\t\n\tvar VOID_ELEMENTS = [\n\t  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n\t  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n\t  'wbr'\n\t];\n\t\n\tmodule.exports = {\n\t  create: createRenderFunction,\n\t  render: function(root, data, context) {\n\t    var render = createRenderFunction(root, context);\n\t    render(data);\n\t    return render;\n\t  }\n\t};\n\t\n\tfunction createRenderFunction(root, context) {\n\t  if (typeof root === 'string') {\n\t    var selector = root;\n\t    root = document.querySelector(selector);\n\t    if (!root) {\n\t      throw new Error('no element found with selector: \"' + selector + '\"');\n\t    }\n\t  }\n\t  var render = createRenderer(root);\n\t  if (arguments.length < 2) context = {};\n\t  return function _render(data) {\n\t    // console.log('rendering with data:', data);\n\t    return incremental.patch(root, render.bind(context, data));\n\t  };\n\t}\n\t\n\tfunction createRenderer(root) {\n\t  var calls = [];\n\t  for (\n\t    var child = root.firstChild; child;\n\t    child = child.nextSibling\n\t  ) {\n\t    switch (child.nodeType) {\n\t      case Node.TEXT_NODE:\n\t        calls.push(createTextRenderer(child));\n\t        break;\n\t      case Node.ELEMENT_NODE:\n\t        calls.push(createElementRenderer(child));\n\t        break;\n\t    }\n\t  }\n\t  return function patch(data) {\n\t    // console.log('patching:', root, 'with', data);\n\t    calls.forEach(function(fn) {\n\t      fn.call(this, data);\n\t    }, this);\n\t  };\n\t}\n\t\n\tfunction createTextRenderer(node) {\n\t  var value = node.nodeValue;\n\t  if (interpolate.isTemplate(value)) {\n\t    return function(data) {\n\t      var text = interpolate.call(this, value, data);\n\t      incremental.text(defined(text) ? text : '');\n\t    };\n\t  }\n\t  return function() {\n\t    incremental.text(value);\n\t  };\n\t}\n\t\n\tfunction createElementRenderer(node) {\n\t  var name = node.nodeName.toLowerCase();\n\t\n\t  // this element will never be rendered if it has a truthy t-skip attribute\n\t  if (node.hasAttribute(T_SKIP)) {\n\t    return noop;\n\t  }\n\t\n\t  var isVoid = isElementVoid(name);\n\t  var attrMap = getAttributeMap(node);\n\t\n\t  var condition = node.hasAttribute(T_IF)\n\t    ? xp.evaluator(node.getAttribute(T_IF))\n\t    : null;\n\t\n\t  if (node.hasAttribute(T_ELSE)) {\n\t    if (condition) throw new Error('element has both t-if and t-else attributes');\n\t    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n\t    if (!ifSibling) throw new Error('element with t-else has no matching t-if sibling');\n\t    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n\t  }\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  var textExpression = node.getAttribute(T_TEXT);\n\t  if (textExpression) {\n\t    var getText = xp.evaluator(textExpression);\n\t    renderChildren = function(data) {\n\t      var value = getText.call(this, data);\n\t      if (defined(value)) {\n\t        incremental.text(String(value));\n\t      }\n\t    };\n\t  } else {\n\t    renderChildren = createRenderer(node);\n\t  }\n\t\n\t  var render = function(data) {\n\t    // console.log('rendering', node, 'with data:', data);\n\t    if (condition && !condition.call(this, data)) {\n\t      return false;\n\t    }\n\t\n\t    var attrs = interpolateAttributes.call(this, attrMap, data);\n\t    if (isVoid) {\n\t      incremental.elementVoid(name, '', attrs);\n\t    } else {\n\t      incremental.elementOpen(name, '', attrs);\n\t      renderChildren.call(this, data);\n\t      incremental.elementClose(name);\n\t    }\n\t  };\n\t\n\t  var eachExpression = node.getAttribute(T_EACH);\n\t  var forEachExpression = node.getAttribute(T_FOREACH);\n\t  var withExpression = node.getAttribute(T_WITH);\n\t\n\t  var symbol = node.getAttribute(T_AS);\n\t\n\t  if (eachExpression) {\n\t    render = renderEach(eachExpression, render, symbol);\n\t  } else if (forEachExpression) {\n\t    renderChildren = renderEach(forEachExpression, renderChildren, symbol);\n\t  } else if (withExpression) {\n\t    render = renderWith(withExpression, render, symbol);\n\t  } else if (symbol) {\n\t    render = symbolSetter(symbol, render);\n\t  }\n\t\n\t  return render;\n\t}\n\t\n\tfunction renderEach(expression, render, symbol) {\n\t  var expr = xp.evaluator(expression);\n\t  return function(data) {\n\t    var values = expr.call(this, data);\n\t    forEach.call(this, values, render, symbol);\n\t  };\n\t}\n\t\n\tfunction renderWith(expression, render, symbol) {\n\t  var expr = xp.evaluator(expression);\n\t  if (symbol) render = symbolSetter(symbol, render);\n\t  return function(data) {\n\t    data = expr.call(this, data);\n\t    render.call(this, data);\n\t  };\n\t}\n\t\n\tfunction getAttributeMap(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = String(attr.name);\n\t    if (name.indexOf(T_NS) === 0) {\n\t      name = name.substr(T_NS.length);\n\t      if (CONTROL_ATTRS.indexOf(name) > -1) {\n\t        continue;\n\t      }\n\t      var getter = xp.evaluator(attr.value);\n\t      switch (name) {\n\t        case 'class':\n\t          getter = transform.className(getter);\n\t          break;\n\t        case 'style':\n\t          getter = transform.style(getter);\n\t          break;\n\t      }\n\t      map[name] = getter;\n\t    } else {\n\t      map[name] = attr.value;\n\t    }\n\t  }\n\t  return map;\n\t}\n\t\n\tfunction interpolateAttributes(attrMap, data) {\n\t  var attrs = [];\n\t  for (var key in attrMap) {\n\t    var value = attrMap[key];\n\t    if (typeof value === 'function') {\n\t      value = value.call(this, data, key);\n\t    }\n\t    if (defined(value)) {\n\t      attrs.push(key, value);\n\t    }\n\t  }\n\t  return attrs;\n\t}\n\t\n\tfunction getPreviousSibling(node, selector) {\n\t  while (node = node.previousSibling) {\n\t    if (!node) break;\n\t    // FIXME this needs a vendor prefix in IE 9+\n\t    // <http://caniuse.com/#search=matches>\n\t    if (node.matches(selector)) return node;\n\t  }\n\t  throw new Error('no previous sibling found matching: ' + selector);\n\t}\n\t\n\tfunction isElementVoid(name) {\n\t  return VOID_ELEMENTS.indexOf(name) > -1;\n\t}\n\t\n\tfunction forEach(data, fn, symbol) {\n\t  var previous;\n\t  var iterate = symbol\n\t    ? symbolSetter(symbol, fn)\n\t    : fn;\n\t\n\t  var INDEX = '$i';\n\t  var each = function(d, i) {\n\t    this[INDEX] = i;\n\t    iterate.call(this, d);\n\t    delete this[INDEX];\n\t  };\n\t\n\t  if (typeof data === 'object') {\n\t    if (Array.isArray(data)) {\n\t      return data.forEach(each, this);\n\t    }\n\t\n\t    var i = 0;\n\t    for (var key in data) {\n\t      if (data.hasOwnProperty(key)) {\n\t        each.call(this, {key: key, value: data[key]}, i++);\n\t      }\n\t    }\n\t  } else if (typeof data === 'string') {\n\t    return data.split('').forEach(each, this);\n\t  }\n\t\n\t  // throw new Error('unable to iterate over ' + (typeof data));\n\t}\n\t\n\tfunction symbolSetter(symbol, fn) {\n\t  return function(data) {\n\t    var previous = set(this, symbol, data);\n\t    fn.call(this, data);\n\t    set(this, symbol, previous);\n\t  };\n\t}\n\t\n\tfunction defined(value) {\n\t  return value !== null && value !== undefined;\n\t}\n\t\n\tfunction not(fn) {\n\t  return function() {\n\t    return !fn.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction set(context, symbol, value) {\n\t  var previous = context[symbol];\n\t  if (value === undefined) {\n\t    delete context[symbol];\n\t  } else {\n\t    context[symbol] = value;\n\t  }\n\t  return previous;\n\t}\n\t\n\tfunction noop() {\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** */\n\texports.notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Similar to the built-in Treewalker class, but simplified and allows direct\n\t * access to modify the currentNode property.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     walker should start traversing.\n\t * @constructor\n\t */\n\tfunction TreeWalker(node) {\n\t  /**\n\t   * Keeps track of the current parent node. This is necessary as the traversal\n\t   * methods may traverse past the last child and we still need a way to get\n\t   * back to the parent.\n\t   * @const @private {!Array<!Node>}\n\t   */\n\t  this.stack_ = [];\n\t\n\t  /**\n\t   * @const {!Element|!DocumentFragment}\n\t   */\n\t  this.root = node;\n\t\n\t  /**\n\t   * @type {?Node}\n\t   */\n\t  this.currentNode = node;\n\t}\n\t\n\t/**\n\t * @return {!Node} The current parent of the current location in the subtree.\n\t */\n\tTreeWalker.prototype.getCurrentParent = function () {\n\t  return this.stack_[this.stack_.length - 1];\n\t};\n\t\n\t/**\n\t * Changes the current location the firstChild of the current location.\n\t */\n\tTreeWalker.prototype.firstChild = function () {\n\t  this.stack_.push(this.currentNode);\n\t  this.currentNode = this.currentNode.firstChild;\n\t};\n\t\n\t/**\n\t * Changes the current location the nextSibling of the current location.\n\t */\n\tTreeWalker.prototype.nextSibling = function () {\n\t  this.currentNode = this.currentNode.nextSibling;\n\t};\n\t\n\t/**\n\t * Changes the current location the parentNode of the current location.\n\t */\n\tTreeWalker.prototype.parentNode = function () {\n\t  this.currentNode = this.stack_.pop();\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     is for.\n\t * @param {?Context} prevContext The previous context.\n\t * @constructor\n\t */\n\tfunction Context(node, prevContext) {\n\t  /**\n\t   * @const {TreeWalker}\n\t   */\n\t  this.walker = new TreeWalker(node);\n\t\n\t  /**\n\t   * @const {Document}\n\t   */\n\t  this.doc = node.ownerDocument;\n\t\n\t  /**\n\t   * Keeps track of what namespace to create new Elements in.\n\t   * @private\n\t   * @const {!Array<(string|undefined)>}\n\t   */\n\t  this.nsStack_ = [undefined];\n\t\n\t  /**\n\t   * @const {?Context}\n\t   */\n\t  this.prevContext = prevContext;\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = exports.notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = exports.notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @return {(string|undefined)} The current namespace to create Elements in.\n\t */\n\tContext.prototype.getCurrentNamespace = function () {\n\t  return this.nsStack_[this.nsStack_.length - 1];\n\t};\n\t\n\t/**\n\t * @param {string=} namespace The namespace to enter.\n\t */\n\tContext.prototype.enterNamespace = function (namespace) {\n\t  this.nsStack_.push(namespace);\n\t};\n\t\n\t/**\n\t * Exits the current namespace\n\t */\n\tContext.prototype.exitNamespace = function () {\n\t  this.nsStack_.pop();\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    exports.notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    exports.notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t * The current context.\n\t * @type {?Context}\n\t */\n\tvar context;\n\t\n\t/**\n\t * Enters a new patch context.\n\t * @param {!Element|!DocumentFragment} node\n\t */\n\tvar enterContext = function (node) {\n\t  context = new Context(node, context);\n\t};\n\t\n\t/**\n\t * Restores the previous patch context.\n\t */\n\tvar restoreContext = function () {\n\t  context = context.prevContext;\n\t};\n\t\n\t/**\n\t * Gets the current patch context.\n\t * @return {?Context}\n\t */\n\tvar getContext = function () {\n\t  return context;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The last child to have been visited within the current pass.\n\t   * @type {?Node}\n\t   */\n\t  this.lastVisitedChild = null;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\texports.symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\texports.applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    el.setAttribute(name, value);\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\texports.applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {string|Object<string,string>} style The style to set. Either a\n\t *     string of css or an object containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t\n\t    for (var prop in style) {\n\t      if (has(style, prop)) {\n\t        elStyle[prop] = style[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    exports.applyProp(el, name, value);\n\t  } else {\n\t    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\texports.attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\texports.attributes[exports.symbols.default] = applyAttributeTyped;\n\t\n\texports.attributes[exports.symbols.placeholder] = function () {};\n\t\n\texports.attributes['style'] = applyStyle;\n\t\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\t\n\t/**\n\t * Enters a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar enterTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    getContext().enterNamespace(SVG_NS);\n\t  } else if (tag === 'foreignObject') {\n\t    getContext().enterNamespace(undefined);\n\t  }\n\t};\n\t\n\t/**\n\t * Exits a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar exitTag = function (tag) {\n\t  if (tag === 'svg' || tag === 'foreignObject') {\n\t    getContext().exitNamespace();\n\t  }\n\t};\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @return {(string|undefined)} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    return SVG_NS;\n\t  }\n\t\n\t  return getContext().getCurrentNamespace();\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag);\n\t  var el;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Node, either a Text or an Element depending on the node name\n\t * provided.\n\t * @param {Document} doc The document with which to create the Node.\n\t * @param {string} nodeName The tag if creating an element or #text to create\n\t *     a Text.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics The static data to initialize the Node\n\t *     with. For an Element, an array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Node}\n\t */\n\tvar createNode = function (doc, nodeName, key, statics) {\n\t  if (nodeName === '#text') {\n\t    return doc.createTextNode('');\n\t  }\n\t\n\t  return createElement(doc, nodeName, key, statics);\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var children = el.children;\n\t  var count = children.length;\n\t\n\t  for (var i = 0; i < count; i += 1) {\n\t    var child = children[i];\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {!Node} parent\n\t * @param {?string=} key\n\t * @return {?Element} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n\t  );\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {!Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t  * Makes sure that keyed Element matches the tag name provided.\n\t  * @param {!Element} node The node that is being matched.\n\t  * @param {string=} tag The tag name of the Element.\n\t  * @param {?string=} key The key of the Element.\n\t  */\n\t  var assertKeyedTagMatches = function (node, tag, key) {\n\t    var nodeName = getData(node).nodeName;\n\t    if (nodeName !== tag) {\n\t      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Checks whether or not a given node matches the specified nodeName and key.\n\t *\n\t * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (node, nodeName, key) {\n\t  var data = getData(node);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return key == data.key && nodeName === data.nodeName;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t * @return {!Node} The matching node.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var currentNode = walker.currentNode;\n\t  var parent = walker.getCurrentParent();\n\t  var matchingNode;\n\t\n\t  // Check to see if we have a node to reuse\n\t  if (currentNode && matches(currentNode, nodeName, key)) {\n\t    matchingNode = currentNode;\n\t  } else {\n\t    var existingNode = getChild(parent, key);\n\t\n\t    // Check to see if the node has moved within the parent or if a new one\n\t    // should be created\n\t    if (existingNode) {\n\t      if (process.env.NODE_ENV !== 'production') {\n\t        assertKeyedTagMatches(existingNode, nodeName, key);\n\t      }\n\t\n\t      matchingNode = existingNode;\n\t    } else {\n\t      matchingNode = createNode(context.doc, nodeName, key, statics);\n\t\n\t      if (key) {\n\t        registerChild(parent, key, matchingNode);\n\t      }\n\t\n\t      context.markCreated(matchingNode);\n\t    }\n\t\n\t    // If the node has a key, remove it from the DOM to prevent a large number\n\t    // of re-orders in the case that it moved far or was completely removed.\n\t    // Since we hold on to a reference through the keyMap, we can always add it\n\t    // back.\n\t    if (currentNode && getData(currentNode).key) {\n\t      parent.replaceChild(matchingNode, currentNode);\n\t      getData(parent).keyMapValid = false;\n\t    } else {\n\t      parent.insertBefore(matchingNode, currentNode);\n\t    }\n\t\n\t    walker.currentNode = matchingNode;\n\t  }\n\t\n\t  return matchingNode;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t * @param {Node} node\n\t */\n\tvar clearUnvisitedDOM = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var lastVisitedChild = data.lastVisitedChild;\n\t  var child = node.lastChild;\n\t  var key;\n\t\n\t  data.lastVisitedChild = null;\n\t\n\t  if (child === lastVisitedChild && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n\t    return;\n\t  }\n\t\n\t  while (child !== lastVisitedChild) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  for (key in keyMap) {\n\t    child = keyMap[key];\n\t    if (!child.parentNode) {\n\t      context.markDeleted(child);\n\t      delete keyMap[key];\n\t    }\n\t  }\n\t\n\t  data.keyMapValid = true;\n\t};\n\t\n\t/**\n\t * Enters an Element, setting the current namespace for nested elements.\n\t * @param {Node} node\n\t */\n\tvar enterNode = function (node) {\n\t  var data = getData(node);\n\t  enterTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Exits an Element, unwinding the current namespace to the previous value.\n\t * @param {Node} node\n\t */\n\tvar exitNode = function (node) {\n\t  var data = getData(node);\n\t  exitTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Marks node's parent as having visited node.\n\t * @param {Node} node\n\t */\n\tvar markVisited = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var parent = walker.getCurrentParent();\n\t  var data = getData(parent);\n\t  data.lastVisitedChild = node;\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar firstChild = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  enterNode(walker.currentNode);\n\t  walker.firstChild();\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextSibling = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  markVisited(walker.currentNode);\n\t  walker.nextSibling();\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar parentNode = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  walker.parentNode();\n\t  exitNode(walker.currentNode);\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  var assertNoUnclosedTags = function (root) {\n\t    var openElement = getContext().walker.getCurrentParent();\n\t    if (!openElement) {\n\t      return;\n\t    }\n\t\n\t    var openTags = [];\n\t    while (openElement && openElement !== root) {\n\t      openTags.push(openElement.nodeName.toLowerCase());\n\t      openElement = openElement.parentNode;\n\t    }\n\t\n\t    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n\t  };\n\t}\n\t\n\t/**\n\t * Patches the document starting at el with the provided function. This function\n\t * may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\texports.patch = function (node, fn, data) {\n\t  enterContext(node);\n\t\n\t  firstChild();\n\t  fn(data);\n\t  parentNode();\n\t  clearUnvisitedDOM(node);\n\t\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNoUnclosedTags(node);\n\t  }\n\t\n\t  getContext().notifyChanges();\n\t  restoreContext();\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t   * Keeps track whether or not we are in an attributes declaration (after\n\t   * elementOpenStart, but before elementOpenEnd).\n\t   * @type {boolean}\n\t   */\n\t  var inAttributes = false;\n\t\n\t  /** Makes sure that the caller is not where attributes are expected. */\n\t  var assertNotInAttributes = function () {\n\t    if (inAttributes) {\n\t      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n\t    }\n\t  };\n\t\n\t  /** Makes sure that the caller is where attributes are expected. */\n\t  var assertInAttributes = function () {\n\t    if (!inAttributes) {\n\t      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that placeholders have a key specified. Otherwise, conditional\n\t   * placeholders and conditional elements next to placeholders will cause\n\t   * placeholder elements to be re-used as non-placeholders and vice versa.\n\t   * @param {string} key\n\t   */\n\t  var assertPlaceholderKeySpecified = function (key) {\n\t    if (!key) {\n\t      throw new Error('Placeholder elements must have a key specified.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that tags are correctly nested.\n\t   * @param {string} tag\n\t   */\n\t  var assertCloseMatchesOpenTag = function (tag) {\n\t    var context = getContext();\n\t    var walker = context.walker;\n\t    var closingNode = walker.getCurrentParent();\n\t    var data = getData(closingNode);\n\t\n\t    if (tag !== data.nodeName) {\n\t      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n\t    }\n\t  };\n\t\n\t  /** Updates the state to being in an attribute declaration. */\n\t  var setInAttributes = function () {\n\t    inAttributes = true;\n\t  };\n\t\n\t  /** Updates the state to not being in an attribute declaration. */\n\t  var setNotInAttributes = function () {\n\t    inAttributes = false;\n\t  };\n\t}\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpen = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    var attr,\n\t        newAttrs = data.newAttrs;\n\t\n\t    for (attr in newAttrs) {\n\t      newAttrs[attr] = undefined;\n\t    }\n\t\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (attr in newAttrs) {\n\t      updateAttribute(node, attr, newAttrs[attr]);\n\t    }\n\t  }\n\t\n\t  firstChild();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\texports.elementOpenStart = function (tag, key, statics) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    setInAttributes();\n\t  }\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\texports.attr = function (name, value) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t  }\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpenEnd = function () {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t    setNotInAttributes();\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementClose = function (tag) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    assertCloseMatchesOpenTag(tag);\n\t  }\n\t\n\t  parentNode();\n\t\n\t  var node = /** @type {!Element} */getContext().walker.currentNode;\n\t\n\t  clearUnvisitedDOM(node);\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementVoid = function (tag, key, statics, var_args) {\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementPlaceholder = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertPlaceholderKeySpecified(key);\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  updateAttribute(node, exports.symbols.placeholder, true);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} var_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\texports.text = function (value, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      formatted = arguments[i](formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar pattern = /{{([^}]+)}}/g;\n\t\n\tmodule.exports = interpolate;\n\t\n\tmodule.exports.isTemplate = function(template) {\n\t  return !!template.match(pattern);\n\t};\n\t\n\tfunction interpolate(template, data) {\n\t  var that = this;\n\t  return template.replace(pattern, function(_, expr) {\n\t    return evaluate.call(that, expr, data);\n\t  });\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar style = function(getter) {\n\t  return function() {\n\t    var data = getter.apply(this, arguments);\n\t    if (data && typeof data === 'object') {\n\t      return formatStyle(data);\n\t    }\n\t    return data;\n\t  };\n\t};\n\t\n\tvar className = function(getter) {\n\t  return function() {\n\t    var data = getter.apply(this, arguments);\n\t    if (data && typeof data === 'object') {\n\t      return formatClassName(data);\n\t    }\n\t    return data;\n\t  };\n\t};\n\t\n\tmodule.exports = {\n\t  style: style,\n\t  className: className\n\t};\n\t\n\tfunction formatStyle(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join('; ');\n\t  }\n\t  return Object.keys(obj)\n\t    .map(function(key) {\n\t      return [\n\t        reformatCamelCase(key),\n\t        ': ',\n\t        obj[key],\n\t        ';'\n\t      ].join('');\n\t    })\n\t    .join(' ');\n\t}\n\t\n\tfunction reformatCamelCase(str) {\n\t  return str.replace(/[A-Z]/g, function(char) {\n\t    return '-' + char.toLowerCase();\n\t  });\n\t}\n\t\n\tfunction formatClassName(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t  return Object.keys(obj).filter(function(key) {\n\t    return !!obj[key];\n\t  }).join(' ');\n\t}\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 008285fd64a423025270\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar render = require('./render');\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: render.create,\n  render: render.render\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*! (C) WebReflection Mit Style License */\n(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/document-register-element/build/document-register-element.js\n ** module id = 1\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render').create;\n\nvar RENDER = '__render';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        console.log('attached!', this);\n        this.update();\n      }},\n\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      render: {value: function(data) {\n        if (!arguments.length) data = this.data;\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      invalidate: {value: function() {\n        this[RENDER] = null;\n        this.render();\n      }},\n\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function property(read, write, value) {\n  return {\n    enumerable: false,\n\n    get: function() {\n      return read ? read.call(this, value) : value;\n    },\n\n    set: function(v) {\n      if (v !== value) {\n        var previous = value;\n        return value = write.call(this, v, previous);\n      }\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 3\n ** module chunks = 0\n **/","var arrow = require('./arrow');\n\nvar evaluate = function(expression, data) {\n  var fn = evaluator(expression);\n  return fn.call(this, data);\n};\n\nvar evaluator = function(expression) {\n  if (arrow.is(expression)) {\n    return arrow.parse(expression);\n  }\n\n  var symbol = 'd' + Date.now();\n  // '.' is just the identity function\n  if (expression.match(/^\\s*\\.\\s*$/)) {\n    return identity;\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    '  with (this) {',\n    '    with (', symbol, ') {',\n    '      return (', expression, ');',\n    '    } ',\n    '  } ',\n    '} catch (error) { }'\n  ].join('\\n'));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator,\n};\n\nfunction identity(d) {\n  return d;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 4\n ** module chunks = 0\n **/","var ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = match[4] || match[5];\n  return new Function(args, [\n    'try {',\n    '  with (this) {',\n    '    return (', body, ');',\n    '  }',\n    '} catch (error) { }'\n  ].join('\\n'));\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 5\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar incremental = require('incremental-dom');\nvar xp = require('./evaluate');\nvar interpolate = require('./interpolate');\nvar transform = require('./transform');\n\n// our attribute namespace\nvar T_NS = 't-';\n\nvar T_AS = T_NS + 'as';\nvar T_SKIP = T_NS + 'skip';\nvar T_IF = T_NS + 'if';\nvar T_ELSE = T_NS + 'else';\nvar T_EACH = T_NS + 'each';\nvar T_FOREACH = T_NS + 'foreach';\nvar T_WITH = T_NS + 'with';\nvar T_TEXT = T_NS + 'text';\n\nvar CONTROL_ATTRS = [\n  'if',\n  'else',\n  'each',\n  'foreach',\n  'with',\n  'text',\n  'as',\n  'skip'\n];\n\nvar VOID_ELEMENTS = [\n  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n  'wbr'\n];\n\nmodule.exports = {\n  create: createRenderFunction,\n  render: function(root, data, context) {\n    var render = createRenderFunction(root, context);\n    render(data);\n    return render;\n  }\n};\n\nfunction createRenderFunction(root, context) {\n  if (typeof root === 'string') {\n    var selector = root;\n    root = document.querySelector(selector);\n    if (!root) {\n      throw new Error('no element found with selector: \"' + selector + '\"');\n    }\n  }\n  var render = createRenderer(root);\n  if (arguments.length < 2) context = {};\n  return function _render(data) {\n    // console.log('rendering with data:', data);\n    return incremental.patch(root, render.bind(context, data));\n  };\n}\n\nfunction createRenderer(root) {\n  var calls = [];\n  for (\n    var child = root.firstChild; child;\n    child = child.nextSibling\n  ) {\n    switch (child.nodeType) {\n      case Node.TEXT_NODE:\n        calls.push(createTextRenderer(child));\n        break;\n      case Node.ELEMENT_NODE:\n        calls.push(createElementRenderer(child));\n        break;\n    }\n  }\n  return function patch(data) {\n    // console.log('patching:', root, 'with', data);\n    calls.forEach(function(fn) {\n      fn.call(this, data);\n    }, this);\n  };\n}\n\nfunction createTextRenderer(node) {\n  var value = node.nodeValue;\n  if (interpolate.isTemplate(value)) {\n    return function(data) {\n      var text = interpolate.call(this, value, data);\n      incremental.text(defined(text) ? text : '');\n    };\n  }\n  return function() {\n    incremental.text(value);\n  };\n}\n\nfunction createElementRenderer(node) {\n  var name = node.nodeName.toLowerCase();\n\n  // this element will never be rendered if it has a truthy t-skip attribute\n  if (node.hasAttribute(T_SKIP)) {\n    return noop;\n  }\n\n  var isVoid = isElementVoid(name);\n  var attrMap = getAttributeMap(node);\n\n  var condition = node.hasAttribute(T_IF)\n    ? xp.evaluator(node.getAttribute(T_IF))\n    : null;\n\n  if (node.hasAttribute(T_ELSE)) {\n    if (condition) throw new Error('element has both t-if and t-else attributes');\n    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n    if (!ifSibling) throw new Error('element with t-else has no matching t-if sibling');\n    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n  }\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  var textExpression = node.getAttribute(T_TEXT);\n  if (textExpression) {\n    var getText = xp.evaluator(textExpression);\n    renderChildren = function(data) {\n      var value = getText.call(this, data);\n      if (defined(value)) {\n        incremental.text(String(value));\n      }\n    };\n  } else {\n    renderChildren = createRenderer(node);\n  }\n\n  var render = function(data) {\n    // console.log('rendering', node, 'with data:', data);\n    if (condition && !condition.call(this, data)) {\n      return false;\n    }\n\n    var attrs = interpolateAttributes.call(this, attrMap, data);\n    if (isVoid) {\n      incremental.elementVoid(name, '', attrs);\n    } else {\n      incremental.elementOpen(name, '', attrs);\n      renderChildren.call(this, data);\n      incremental.elementClose(name);\n    }\n  };\n\n  var eachExpression = node.getAttribute(T_EACH);\n  var forEachExpression = node.getAttribute(T_FOREACH);\n  var withExpression = node.getAttribute(T_WITH);\n\n  var symbol = node.getAttribute(T_AS);\n\n  if (eachExpression) {\n    render = renderEach(eachExpression, render, symbol);\n  } else if (forEachExpression) {\n    renderChildren = renderEach(forEachExpression, renderChildren, symbol);\n  } else if (withExpression) {\n    render = renderWith(withExpression, render, symbol);\n  } else if (symbol) {\n    render = symbolSetter(symbol, render);\n  }\n\n  return render;\n}\n\nfunction renderEach(expression, render, symbol) {\n  var expr = xp.evaluator(expression);\n  return function(data) {\n    var values = expr.call(this, data);\n    forEach.call(this, values, render, symbol);\n  };\n}\n\nfunction renderWith(expression, render, symbol) {\n  var expr = xp.evaluator(expression);\n  if (symbol) render = symbolSetter(symbol, render);\n  return function(data) {\n    data = expr.call(this, data);\n    render.call(this, data);\n  };\n}\n\nfunction getAttributeMap(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = String(attr.name);\n    if (name.indexOf(T_NS) === 0) {\n      name = name.substr(T_NS.length);\n      if (CONTROL_ATTRS.indexOf(name) > -1) {\n        continue;\n      }\n      var getter = xp.evaluator(attr.value);\n      switch (name) {\n        case 'class':\n          getter = transform.className(getter);\n          break;\n        case 'style':\n          getter = transform.style(getter);\n          break;\n      }\n      map[name] = getter;\n    } else {\n      map[name] = attr.value;\n    }\n  }\n  return map;\n}\n\nfunction interpolateAttributes(attrMap, data) {\n  var attrs = [];\n  for (var key in attrMap) {\n    var value = attrMap[key];\n    if (typeof value === 'function') {\n      value = value.call(this, data, key);\n    }\n    if (defined(value)) {\n      attrs.push(key, value);\n    }\n  }\n  return attrs;\n}\n\nfunction getPreviousSibling(node, selector) {\n  while (node = node.previousSibling) {\n    if (!node) break;\n    // FIXME this needs a vendor prefix in IE 9+\n    // <http://caniuse.com/#search=matches>\n    if (node.matches(selector)) return node;\n  }\n  throw new Error('no previous sibling found matching: ' + selector);\n}\n\nfunction isElementVoid(name) {\n  return VOID_ELEMENTS.indexOf(name) > -1;\n}\n\nfunction forEach(data, fn, symbol) {\n  var previous;\n  var iterate = symbol\n    ? symbolSetter(symbol, fn)\n    : fn;\n\n  var INDEX = '$i';\n  var each = function(d, i) {\n    this[INDEX] = i;\n    iterate.call(this, d);\n    delete this[INDEX];\n  };\n\n  if (typeof data === 'object') {\n    if (Array.isArray(data)) {\n      return data.forEach(each, this);\n    }\n\n    var i = 0;\n    for (var key in data) {\n      if (data.hasOwnProperty(key)) {\n        each.call(this, {key: key, value: data[key]}, i++);\n      }\n    }\n  } else if (typeof data === 'string') {\n    return data.split('').forEach(each, this);\n  }\n\n  // throw new Error('unable to iterate over ' + (typeof data));\n}\n\nfunction symbolSetter(symbol, fn) {\n  return function(data) {\n    var previous = set(this, symbol, data);\n    fn.call(this, data);\n    set(this, symbol, previous);\n  };\n}\n\nfunction defined(value) {\n  return value !== null && value !== undefined;\n}\n\nfunction not(fn) {\n  return function() {\n    return !fn.apply(this, arguments);\n  };\n}\n\nfunction set(context, symbol, value) {\n  var previous = context[symbol];\n  if (value === undefined) {\n    delete context[symbol];\n  } else {\n    context[symbol] = value;\n  }\n  return previous;\n}\n\nfunction noop() {\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 6\n ** module chunks = 0\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     walker should start traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /**\n   * @const {!Element|!DocumentFragment}\n   */\n  this.root = node;\n\n  /**\n   * @type {?Node}\n   */\n  this.currentNode = node;\n}\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function () {\n  return this.stack_[this.stack_.length - 1];\n};\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function () {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function () {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function () {\n  this.currentNode = this.stack_.pop();\n};\n\n/**\n * Keeps track of the state of a patch.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     is for.\n * @param {?Context} prevContext The previous context.\n * @constructor\n */\nfunction Context(node, prevContext) {\n  /**\n   * @const {TreeWalker}\n   */\n  this.walker = new TreeWalker(node);\n\n  /**\n   * @const {Document}\n   */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @private\n   * @const {!Array<(string|undefined)>}\n   */\n  this.nsStack_ = [undefined];\n\n  /**\n   * @const {?Context}\n   */\n  this.prevContext = prevContext;\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n/**\n * @return {(string|undefined)} The current namespace to create Elements in.\n */\nContext.prototype.getCurrentNamespace = function () {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n/**\n * @param {string=} namespace The namespace to enter.\n */\nContext.prototype.enterNamespace = function (namespace) {\n  this.nsStack_.push(namespace);\n};\n\n/**\n * Exits the current namespace\n */\nContext.prototype.exitNamespace = function () {\n  this.nsStack_.pop();\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * The current context.\n * @type {?Context}\n */\nvar context;\n\n/**\n * Enters a new patch context.\n * @param {!Element|!DocumentFragment} node\n */\nvar enterContext = function (node) {\n  context = new Context(node, context);\n};\n\n/**\n * Restores the previous patch context.\n */\nvar restoreContext = function () {\n  context = context.prevContext;\n};\n\n/**\n * Gets the current patch context.\n * @return {?Context}\n */\nvar getContext = function () {\n  return context;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * @type {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {string|Object<string,string>} style The style to set. Either a\n *     string of css or an object containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n\n    for (var prop in style) {\n      if (has(style, prop)) {\n        elStyle[prop] = style[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function () {};\n\nexports.attributes['style'] = applyStyle;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function (tag) {\n  if (tag === 'svg') {\n    getContext().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getContext().enterNamespace(undefined);\n  }\n};\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function (tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getContext().exitNamespace();\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {(string|undefined)} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getContext().getCurrentNamespace();\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function (doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Node} parent\n * @param {?string=} key\n * @return {?Element} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n  );\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!Element} node The node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function (node, tag, key) {\n    var nodeName = getData(node).nodeName;\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n    }\n  };\n}\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key && nodeName === data.nodeName;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  var context = getContext();\n  var walker = context.walker;\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(existingNode, nodeName, key);\n      }\n\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(context.doc, nodeName, key, statics);\n\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n\n      context.markCreated(matchingNode);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      parent.replaceChild(matchingNode, currentNode);\n      getData(parent).keyMapValid = false;\n    } else {\n      parent.insertBefore(matchingNode, currentNode);\n    }\n\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {Node} node\n */\nvar clearUnvisitedDOM = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var lastVisitedChild = data.lastVisitedChild;\n  var child = node.lastChild;\n  var key;\n\n  data.lastVisitedChild = null;\n\n  if (child === lastVisitedChild && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n    return;\n  }\n\n  while (child !== lastVisitedChild) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  for (key in keyMap) {\n    child = keyMap[key];\n    if (!child.parentNode) {\n      context.markDeleted(child);\n      delete keyMap[key];\n    }\n  }\n\n  data.keyMapValid = true;\n};\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {Node} node\n */\nvar enterNode = function (node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {Node} node\n */\nvar exitNode = function (node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n/**\n * Marks node's parent as having visited node.\n * @param {Node} node\n */\nvar markVisited = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function () {\n  var context = getContext();\n  var walker = context.walker;\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function () {\n  var context = getContext();\n  var walker = context.walker;\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function () {\n  var context = getContext();\n  var walker = context.walker;\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function (root) {\n    var openElement = getContext().walker.getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n  };\n}\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function (node, fn, data) {\n  enterContext(node);\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  getContext().notifyChanges();\n  restoreContext();\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function () {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n    }\n  };\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function () {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n    }\n  };\n\n  /**\n   * Makes sure that placeholders have a key specified. Otherwise, conditional\n   * placeholders and conditional elements next to placeholders will cause\n   * placeholder elements to be re-used as non-placeholders and vice versa.\n   * @param {string} key\n   */\n  var assertPlaceholderKeySpecified = function (key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function (tag) {\n    var context = getContext();\n    var walker = context.walker;\n    var closingNode = walker.getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n    }\n  };\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function () {\n    inAttributes = true;\n  };\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function () {\n    inAttributes = false;\n  };\n}\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var attr,\n        newAttrs = data.newAttrs;\n\n    for (attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = /** @type {!Element} */getContext().walker.currentNode;\n\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function (tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  var node = exports.elementOpen.apply(null, arguments);\n  updateAttribute(node, exports.symbols.placeholder, true);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n  return node;\n};\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/dist/incremental-dom-cjs.js\n ** module id = 7\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 8\n ** module chunks = 0\n **/","var evaluate = require('./evaluate').evaluate;\nvar pattern = /{{([^}]+)}}/g;\n\nmodule.exports = interpolate;\n\nmodule.exports.isTemplate = function(template) {\n  return !!template.match(pattern);\n};\n\nfunction interpolate(template, data) {\n  var that = this;\n  return template.replace(pattern, function(_, expr) {\n    return evaluate.call(that, expr, data);\n  });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/interpolate.js\n ** module id = 9\n ** module chunks = 0\n **/","var style = function(getter) {\n  return function() {\n    var data = getter.apply(this, arguments);\n    if (data && typeof data === 'object') {\n      return formatStyle(data);\n    }\n    return data;\n  };\n};\n\nvar className = function(getter) {\n  return function() {\n    var data = getter.apply(this, arguments);\n    if (data && typeof data === 'object') {\n      return formatClassName(data);\n    }\n    return data;\n  };\n};\n\nmodule.exports = {\n  style: style,\n  className: className\n};\n\nfunction formatStyle(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join('; ');\n  }\n  return Object.keys(obj)\n    .map(function(key) {\n      return [\n        reformatCamelCase(key),\n        ': ',\n        obj[key],\n        ';'\n      ].join('');\n    })\n    .join(' ');\n}\n\nfunction reformatCamelCase(str) {\n  return str.replace(/[A-Z]/g, function(char) {\n    return '-' + char.toLowerCase();\n  });\n}\n\nfunction formatClassName(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n  return Object.keys(obj).filter(function(key) {\n    return !!obj[key];\n  }).join(' ');\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/transform.js\n ** module id = 10\n ** module chunks = 0\n **/"],"sourceRoot":""}
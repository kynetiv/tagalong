{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap 0c53c91c559b76c4bbc9","webpack:///./src/main.js","webpack:///./~/document-register-element/build/document-register-element.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/render.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./src/transform.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Template","render","window","tagalong","createRenderer","create","e","t","n","r","rt","length","dt","it","nt","b","ot","st","j","querySelectorAll","w","getAttribute","nodeName","toUpperCase","S","y","v","d","ut","indexOf","at","currentTarget","attrChange","attrName","i","target","Q","attributeChangedCallback","a","prevValue","l","newValue","ft","X","push","lt","K","removeEventListener","h","detail","o","s","B","pt","ct","this","q","G","ht","D","et","observe","z","J","setAttribute","Z","addEventListener","createdCallback","created","F","E","contains","splice","tt","Y","Math","random","u","f","g","documentElement","x","prototype","T","hasOwnProperty","N","isPrototypeOf","C","defineProperty","k","getOwnPropertyDescriptor","L","getOwnPropertyNames","A","getPrototypeOf","O","setPrototypeOf","M","__proto__","_","vt","P","MutationObserver","WebKitMutationObserver","H","HTMLElement","Element","Node","nodeType","I","cloneNode","R","removeAttribute","U","createElement","attributes","characterData","attributeOldValue","W","V","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","$","value","CustomEvent","bubbles","dispatchEvent","hasAttribute","propertyName","name","className","type","addedNodes","removedNodes","attributeName","oldValue","childList","subtree","shift","apply","arguments","toLowerCase","innerHTMLHelper","Error","test","concat","document","Object","property","evaluate","RENDER","DATA_ATTR","registerElement","attachedCallback","console","log","update","attr","previous","expr","data","invalidate","read","write","enumerable","get","set","arrow","expression","context","fn","evaluator","is","parseArrow","symbol","Date","now","match","Function","join","ARROW_PATTERN","isArrow","String","args","body","parse","createRenderFunction","root","selector","querySelector","incremental","patch","bind","calls","child","firstChild","nextSibling","TEXT_NODE","createTextRenderer","ELEMENT_NODE","createElementRenderer","forEach","node","text","nodeValue","isVoid","isElementVoid","attrMap","getAttributeMap","condition","T_IF","xp","T_ELSE","ifSibling","getPreviousSibling","not","renderChildren","textExpression","T_TEXT","getText","defined","attrs","interpolateAttributes","elementVoid","elementOpen","elementClose","eachExpression","T_EACH","forEachExpression","T_FOREACH","renderEach","values","map","CONTROL_ATTRS","T_NAMESPACE","getter","substr","transform","style","key","previousSibling","matches","VOID_ELEMENTS","undefined","process","TreeWalker","stack_","currentNode","Context","prevContext","walker","doc","ownerDocument","nsStack_","notifications","nodesCreated","deleted","nodesDeleted","NodeData","createMap","attrsArr","newAttrs","keyMap","keyMapValid","lastVisitedChild","getCurrentParent","parentNode","pop","getCurrentNamespace","enterNamespace","namespace","exitNamespace","markCreated","markDeleted","notifyChanges","enterContext","restoreContext","getContext","has","initData","getData","symbols","default","placeholder","applyAttr","el","applyProp","applyStyle","cssText","elStyle","prop","applyAttributeTyped","updateAttribute","mutator","SVG_NS","enterTag","tag","exitTag","getNamespaceForTag","statics","createElementNS","createNode","createTextNode","createKeyMap","children","count","getKeyMap","getChild","parent","registerChild","env","NODE_ENV","assertKeyedTagMatches","alignWithDOM","matchingNode","existingNode","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","enterNode","exitNode","markVisited","assertNoUnclosedTags","openElement","openTags","ATTRIBUTES_OFFSET","argsBuilder","inAttributes","assertNotInAttributes","assertInAttributes","assertPlaceholderKeySpecified","assertCloseMatchesOpenTag","closingNode","setInAttributes","setNotInAttributes","var_args","attrsChanged","elementOpenStart","elementOpenEnd","elementPlaceholder","formatted","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","clearTimeout","Item","fun","array","noop","nextTick","Array","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","formatStyle","obj","isArray","keys","reformatCamelCase","str","replace","char","formatClassName","filter"],"mappings":"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","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t\n\tvar Template = __webpack_require__(2);\n\tvar render = __webpack_require__(6);\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: render.create,\n\t  render: render.render\n\t};\n\t\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*! (C) WebReflection Mit Style License */\n\t(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(3);\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar createRenderer = __webpack_require__(6).create;\n\t\n\tvar RENDER = '__render';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        console.log('attached!', this);\n\t        this.update();\n\t      }},\n\t\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      render: {value: function(data) {\n\t        if (!arguments.length) data = this.data;\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t        this.render();\n\t      }},\n\t\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, value) {\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      return read ? read.call(this, value) : value;\n\t    },\n\t\n\t    set: function(v) {\n\t      if (v !== value) {\n\t        var previous = value;\n\t        return value = write.call(this, v, previous);\n\t      }\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrow = __webpack_require__(5);\n\t\n\tvar evaluate = function(expression, context) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, context);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (arrow.is(expression)) {\n\t    return parseArrow(expression);\n\t  }\n\t\n\t  var symbol = 'd' + Date.now();\n\t  // '.' is just the identity function\n\t  if (expression === '.') {\n\t    return function identity(d) { return d; };\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    'with (', symbol, ' || {}) {',\n\t    '  return ', expression, ';',\n\t    '} ',\n\t    '} catch (error) { }'\n\t  ].join(''));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator,\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = match[4] || match[5];\n\t  return new Function(args, 'return (' + body + ')');\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar incremental = __webpack_require__(7);\n\tvar xp = __webpack_require__(4);\n\tvar transform = __webpack_require__(9);\n\t\n\tvar T_NAMESPACE = 't-';\n\tvar T_IF = T_NAMESPACE + 'if';\n\tvar T_ELSE = T_NAMESPACE + 'else';\n\tvar T_EACH = T_NAMESPACE + 'each';\n\tvar T_TEXT = T_NAMESPACE + 'text';\n\tvar T_FOREACH = T_NAMESPACE + 'foreach';\n\t\n\tvar CONTROL_ATTRS = [T_IF, T_ELSE, T_EACH, T_FOREACH, T_TEXT];\n\t\n\tvar VOID_ELEMENTS = [\n\t  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n\t  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n\t  'wbr'\n\t];\n\t\n\tmodule.exports = {\n\t  create: createRenderFunction,\n\t  render: function(root, data) {\n\t    var render = createRenderFunction(root);\n\t    render(data);\n\t    return render;\n\t  }\n\t};\n\t\n\tfunction createRenderFunction(root) {\n\t  if (typeof root === 'string') {\n\t    var selector = root;\n\t    root = document.querySelector(selector);\n\t    if (!root) {\n\t      throw new Error('no element found with selector: \"' + selector + '\"');\n\t    }\n\t  }\n\t  var render = createRenderer(root);\n\t  return function _render(data) {\n\t    // console.log('rendering with data:', data);\n\t    return incremental.patch(root, render.bind(this, data));\n\t  };\n\t}\n\t\n\tfunction createRenderer(root) {\n\t  var calls = [];\n\t  for (\n\t    var child = root.firstChild; child;\n\t    child = child.nextSibling\n\t  ) {\n\t    switch (child.nodeType) {\n\t      case Node.TEXT_NODE:\n\t        calls.push(createTextRenderer(child));\n\t        break;\n\t      case Node.ELEMENT_NODE:\n\t        calls.push(createElementRenderer(child));\n\t        break;\n\t    }\n\t  }\n\t  return function patch(data) {\n\t    // console.log('patching:', root, 'with', data);\n\t    calls.forEach(function(fn) {\n\t      fn(data);\n\t    });\n\t  };\n\t}\n\t\n\tfunction createTextRenderer(node) {\n\t  // TODO: expand {{ expressions }} ?\n\t  return function(data) {\n\t    incremental.text(node.nodeValue);\n\t  };\n\t}\n\t\n\tfunction createElementRenderer(node) {\n\t  var name = node.nodeName.toLowerCase();\n\t\n\t  var isVoid = isElementVoid(name);\n\t  var attrMap = getAttributeMap(node);\n\t\n\t  var condition = node.hasAttribute(T_IF)\n\t    ? xp.evaluator(node.getAttribute(T_IF))\n\t    : null;\n\t\n\t  if (node.hasAttribute(T_ELSE)) {\n\t    if (condition) throw new Error('element has both t-if and t-else attributes');\n\t    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n\t    if (!ifSibling) throw new Error('element with t-else has no matching t-if sibling');\n\t    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n\t  }\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  var textExpression = node.getAttribute(T_TEXT);\n\t  if (textExpression) {\n\t    var getText = xp.evaluator(textExpression);\n\t    renderChildren = function(data) {\n\t      var value = getText(data);\n\t      if (defined(value)) {\n\t        incremental.text(String(value));\n\t      }\n\t    };\n\t  } else {\n\t    renderChildren = createRenderer(node);\n\t  }\n\t\n\t  var render = function(data) {\n\t    // console.log('rendering', node, 'with data:', data);\n\t    if (condition && !condition(data)) {\n\t      return false;\n\t    }\n\t\n\t    var attrs = interpolateAttributes(attrMap, data);\n\t    if (isVoid) {\n\t      incremental.elementVoid(name, '', attrs);\n\t    } else {\n\t      incremental.elementOpen(name, '', attrs);\n\t      renderChildren(data);\n\t      incremental.elementClose(name);\n\t    }\n\t  };\n\t\n\t  var eachExpression = node.getAttribute(T_EACH);\n\t  var forEachExpression = node.getAttribute(T_FOREACH);\n\t\n\t  // <ul><li t-each=\"items\">{{ . }}</li></ul>\n\t  if (eachExpression) {\n\t    // console.info('render each:', node, eachExpression);\n\t    render = renderEach(eachExpression, render);\n\t  // <ul t-foreach=\"items\"><li>{{ . }}</li></ul>\n\t  } else if (forEachExpression) {\n\t    // console.info('render foreach:', node, forEachExpression);\n\t    renderChildren = renderEach(forEachExpression, renderChildren);\n\t  } else {\n\t    // console.info('render once:', node);\n\t  }\n\t\n\t  return render;\n\t}\n\t\n\tfunction renderEach(expression, render) {\n\t  return function(data) {\n\t    var values = xp.evaluate(expression, data);\n\t    forEach(values, render);\n\t  };\n\t}\n\t\n\tfunction getAttributeMap(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = String(attr.name);\n\t    if (CONTROL_ATTRS.indexOf(name) > -1) {\n\t      // console.info('skipping control attribute', name, 'for', node);\n\t      continue;\n\t    } else if (name.indexOf(T_NAMESPACE) === 0) {\n\t      var getter = xp.evaluator(attr.value);\n\t      name = name.substr(T_NAMESPACE.length);\n\t      switch (name) {\n\t        case 'class':\n\t          getter = transform.className(getter);\n\t          break;\n\t        case 'style':\n\t          getter = transform.style(getter);\n\t          break;\n\t      }\n\t      map[name] = getter;\n\t    } else {\n\t      map[name] = attr.value;\n\t    }\n\t  }\n\t  return map;\n\t}\n\t\n\tfunction interpolateAttributes(attrMap, data) {\n\t  var attrs = [];\n\t  for (var key in attrMap) {\n\t    var value = attrMap[key];\n\t    if (typeof value === 'function') {\n\t      value = value.call(this, data, key);\n\t    }\n\t    if (defined(value)) {\n\t      attrs.push(key, value);\n\t    }\n\t  }\n\t  return attrs;\n\t}\n\t\n\tfunction getPreviousSibling(node, selector) {\n\t  while (node = node.previousSibling) {\n\t    if (!node) break;\n\t    if (node.matches(selector)) return node;\n\t  }\n\t  throw new Error('no previous sibling found matching: ' + selector);\n\t}\n\t\n\tfunction isElementVoid(name) {\n\t  return VOID_ELEMENTS.indexOf(name) > -1;\n\t}\n\t\n\tfunction forEach(data, fn) {\n\t  return data.forEach(fn, this);\n\t}\n\t\n\tfunction defined(value) {\n\t  return value !== null && value !== undefined;\n\t}\n\t\n\tfunction not(fn) {\n\t  return function() {\n\t    return !fn.apply(this, arguments);\n\t  };\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** */\n\texports.notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Similar to the built-in Treewalker class, but simplified and allows direct\n\t * access to modify the currentNode property.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     walker should start traversing.\n\t * @constructor\n\t */\n\tfunction TreeWalker(node) {\n\t  /**\n\t   * Keeps track of the current parent node. This is necessary as the traversal\n\t   * methods may traverse past the last child and we still need a way to get\n\t   * back to the parent.\n\t   * @const @private {!Array<!Node>}\n\t   */\n\t  this.stack_ = [];\n\t\n\t  /**\n\t   * @const {!Element|!DocumentFragment}\n\t   */\n\t  this.root = node;\n\t\n\t  /**\n\t   * @type {?Node}\n\t   */\n\t  this.currentNode = node;\n\t}\n\t\n\t/**\n\t * @return {!Node} The current parent of the current location in the subtree.\n\t */\n\tTreeWalker.prototype.getCurrentParent = function () {\n\t  return this.stack_[this.stack_.length - 1];\n\t};\n\t\n\t/**\n\t * Changes the current location the firstChild of the current location.\n\t */\n\tTreeWalker.prototype.firstChild = function () {\n\t  this.stack_.push(this.currentNode);\n\t  this.currentNode = this.currentNode.firstChild;\n\t};\n\t\n\t/**\n\t * Changes the current location the nextSibling of the current location.\n\t */\n\tTreeWalker.prototype.nextSibling = function () {\n\t  this.currentNode = this.currentNode.nextSibling;\n\t};\n\t\n\t/**\n\t * Changes the current location the parentNode of the current location.\n\t */\n\tTreeWalker.prototype.parentNode = function () {\n\t  this.currentNode = this.stack_.pop();\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     is for.\n\t * @param {?Context} prevContext The previous context.\n\t * @constructor\n\t */\n\tfunction Context(node, prevContext) {\n\t  /**\n\t   * @const {TreeWalker}\n\t   */\n\t  this.walker = new TreeWalker(node);\n\t\n\t  /**\n\t   * @const {Document}\n\t   */\n\t  this.doc = node.ownerDocument;\n\t\n\t  /**\n\t   * Keeps track of what namespace to create new Elements in.\n\t   * @private\n\t   * @const {!Array<(string|undefined)>}\n\t   */\n\t  this.nsStack_ = [undefined];\n\t\n\t  /**\n\t   * @const {?Context}\n\t   */\n\t  this.prevContext = prevContext;\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = exports.notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = exports.notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @return {(string|undefined)} The current namespace to create Elements in.\n\t */\n\tContext.prototype.getCurrentNamespace = function () {\n\t  return this.nsStack_[this.nsStack_.length - 1];\n\t};\n\t\n\t/**\n\t * @param {string=} namespace The namespace to enter.\n\t */\n\tContext.prototype.enterNamespace = function (namespace) {\n\t  this.nsStack_.push(namespace);\n\t};\n\t\n\t/**\n\t * Exits the current namespace\n\t */\n\tContext.prototype.exitNamespace = function () {\n\t  this.nsStack_.pop();\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    exports.notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    exports.notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t * The current context.\n\t * @type {?Context}\n\t */\n\tvar context;\n\t\n\t/**\n\t * Enters a new patch context.\n\t * @param {!Element|!DocumentFragment} node\n\t */\n\tvar enterContext = function (node) {\n\t  context = new Context(node, context);\n\t};\n\t\n\t/**\n\t * Restores the previous patch context.\n\t */\n\tvar restoreContext = function () {\n\t  context = context.prevContext;\n\t};\n\t\n\t/**\n\t * Gets the current patch context.\n\t * @return {?Context}\n\t */\n\tvar getContext = function () {\n\t  return context;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The last child to have been visited within the current pass.\n\t   * @type {?Node}\n\t   */\n\t  this.lastVisitedChild = null;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\texports.symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\texports.applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    el.setAttribute(name, value);\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\texports.applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {string|Object<string,string>} style The style to set. Either a\n\t *     string of css or an object containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t\n\t    for (var prop in style) {\n\t      if (has(style, prop)) {\n\t        elStyle[prop] = style[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    exports.applyProp(el, name, value);\n\t  } else {\n\t    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\texports.attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\texports.attributes[exports.symbols.default] = applyAttributeTyped;\n\t\n\texports.attributes[exports.symbols.placeholder] = function () {};\n\t\n\texports.attributes['style'] = applyStyle;\n\t\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\t\n\t/**\n\t * Enters a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar enterTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    getContext().enterNamespace(SVG_NS);\n\t  } else if (tag === 'foreignObject') {\n\t    getContext().enterNamespace(undefined);\n\t  }\n\t};\n\t\n\t/**\n\t * Exits a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar exitTag = function (tag) {\n\t  if (tag === 'svg' || tag === 'foreignObject') {\n\t    getContext().exitNamespace();\n\t  }\n\t};\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @return {(string|undefined)} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    return SVG_NS;\n\t  }\n\t\n\t  return getContext().getCurrentNamespace();\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag);\n\t  var el;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Node, either a Text or an Element depending on the node name\n\t * provided.\n\t * @param {Document} doc The document with which to create the Node.\n\t * @param {string} nodeName The tag if creating an element or #text to create\n\t *     a Text.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics The static data to initialize the Node\n\t *     with. For an Element, an array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Node}\n\t */\n\tvar createNode = function (doc, nodeName, key, statics) {\n\t  if (nodeName === '#text') {\n\t    return doc.createTextNode('');\n\t  }\n\t\n\t  return createElement(doc, nodeName, key, statics);\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var children = el.children;\n\t  var count = children.length;\n\t\n\t  for (var i = 0; i < count; i += 1) {\n\t    var child = children[i];\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {!Node} parent\n\t * @param {?string=} key\n\t * @return {?Element} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n\t  );\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {!Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t  * Makes sure that keyed Element matches the tag name provided.\n\t  * @param {!Element} node The node that is being matched.\n\t  * @param {string=} tag The tag name of the Element.\n\t  * @param {?string=} key The key of the Element.\n\t  */\n\t  var assertKeyedTagMatches = function (node, tag, key) {\n\t    var nodeName = getData(node).nodeName;\n\t    if (nodeName !== tag) {\n\t      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Checks whether or not a given node matches the specified nodeName and key.\n\t *\n\t * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (node, nodeName, key) {\n\t  var data = getData(node);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return key == data.key && nodeName === data.nodeName;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t * @return {!Node} The matching node.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var currentNode = walker.currentNode;\n\t  var parent = walker.getCurrentParent();\n\t  var matchingNode;\n\t\n\t  // Check to see if we have a node to reuse\n\t  if (currentNode && matches(currentNode, nodeName, key)) {\n\t    matchingNode = currentNode;\n\t  } else {\n\t    var existingNode = getChild(parent, key);\n\t\n\t    // Check to see if the node has moved within the parent or if a new one\n\t    // should be created\n\t    if (existingNode) {\n\t      if (process.env.NODE_ENV !== 'production') {\n\t        assertKeyedTagMatches(existingNode, nodeName, key);\n\t      }\n\t\n\t      matchingNode = existingNode;\n\t    } else {\n\t      matchingNode = createNode(context.doc, nodeName, key, statics);\n\t\n\t      if (key) {\n\t        registerChild(parent, key, matchingNode);\n\t      }\n\t\n\t      context.markCreated(matchingNode);\n\t    }\n\t\n\t    // If the node has a key, remove it from the DOM to prevent a large number\n\t    // of re-orders in the case that it moved far or was completely removed.\n\t    // Since we hold on to a reference through the keyMap, we can always add it\n\t    // back.\n\t    if (currentNode && getData(currentNode).key) {\n\t      parent.replaceChild(matchingNode, currentNode);\n\t      getData(parent).keyMapValid = false;\n\t    } else {\n\t      parent.insertBefore(matchingNode, currentNode);\n\t    }\n\t\n\t    walker.currentNode = matchingNode;\n\t  }\n\t\n\t  return matchingNode;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t * @param {Node} node\n\t */\n\tvar clearUnvisitedDOM = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var lastVisitedChild = data.lastVisitedChild;\n\t  var child = node.lastChild;\n\t  var key;\n\t\n\t  data.lastVisitedChild = null;\n\t\n\t  if (child === lastVisitedChild && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n\t    return;\n\t  }\n\t\n\t  while (child !== lastVisitedChild) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  for (key in keyMap) {\n\t    child = keyMap[key];\n\t    if (!child.parentNode) {\n\t      context.markDeleted(child);\n\t      delete keyMap[key];\n\t    }\n\t  }\n\t\n\t  data.keyMapValid = true;\n\t};\n\t\n\t/**\n\t * Enters an Element, setting the current namespace for nested elements.\n\t * @param {Node} node\n\t */\n\tvar enterNode = function (node) {\n\t  var data = getData(node);\n\t  enterTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Exits an Element, unwinding the current namespace to the previous value.\n\t * @param {Node} node\n\t */\n\tvar exitNode = function (node) {\n\t  var data = getData(node);\n\t  exitTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Marks node's parent as having visited node.\n\t * @param {Node} node\n\t */\n\tvar markVisited = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var parent = walker.getCurrentParent();\n\t  var data = getData(parent);\n\t  data.lastVisitedChild = node;\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar firstChild = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  enterNode(walker.currentNode);\n\t  walker.firstChild();\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextSibling = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  markVisited(walker.currentNode);\n\t  walker.nextSibling();\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar parentNode = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  walker.parentNode();\n\t  exitNode(walker.currentNode);\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  var assertNoUnclosedTags = function (root) {\n\t    var openElement = getContext().walker.getCurrentParent();\n\t    if (!openElement) {\n\t      return;\n\t    }\n\t\n\t    var openTags = [];\n\t    while (openElement && openElement !== root) {\n\t      openTags.push(openElement.nodeName.toLowerCase());\n\t      openElement = openElement.parentNode;\n\t    }\n\t\n\t    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n\t  };\n\t}\n\t\n\t/**\n\t * Patches the document starting at el with the provided function. This function\n\t * may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\texports.patch = function (node, fn, data) {\n\t  enterContext(node);\n\t\n\t  firstChild();\n\t  fn(data);\n\t  parentNode();\n\t  clearUnvisitedDOM(node);\n\t\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNoUnclosedTags(node);\n\t  }\n\t\n\t  getContext().notifyChanges();\n\t  restoreContext();\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t   * Keeps track whether or not we are in an attributes declaration (after\n\t   * elementOpenStart, but before elementOpenEnd).\n\t   * @type {boolean}\n\t   */\n\t  var inAttributes = false;\n\t\n\t  /** Makes sure that the caller is not where attributes are expected. */\n\t  var assertNotInAttributes = function () {\n\t    if (inAttributes) {\n\t      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n\t    }\n\t  };\n\t\n\t  /** Makes sure that the caller is where attributes are expected. */\n\t  var assertInAttributes = function () {\n\t    if (!inAttributes) {\n\t      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that placeholders have a key specified. Otherwise, conditional\n\t   * placeholders and conditional elements next to placeholders will cause\n\t   * placeholder elements to be re-used as non-placeholders and vice versa.\n\t   * @param {string} key\n\t   */\n\t  var assertPlaceholderKeySpecified = function (key) {\n\t    if (!key) {\n\t      throw new Error('Placeholder elements must have a key specified.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that tags are correctly nested.\n\t   * @param {string} tag\n\t   */\n\t  var assertCloseMatchesOpenTag = function (tag) {\n\t    var context = getContext();\n\t    var walker = context.walker;\n\t    var closingNode = walker.getCurrentParent();\n\t    var data = getData(closingNode);\n\t\n\t    if (tag !== data.nodeName) {\n\t      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n\t    }\n\t  };\n\t\n\t  /** Updates the state to being in an attribute declaration. */\n\t  var setInAttributes = function () {\n\t    inAttributes = true;\n\t  };\n\t\n\t  /** Updates the state to not being in an attribute declaration. */\n\t  var setNotInAttributes = function () {\n\t    inAttributes = false;\n\t  };\n\t}\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpen = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    var attr,\n\t        newAttrs = data.newAttrs;\n\t\n\t    for (attr in newAttrs) {\n\t      newAttrs[attr] = undefined;\n\t    }\n\t\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (attr in newAttrs) {\n\t      updateAttribute(node, attr, newAttrs[attr]);\n\t    }\n\t  }\n\t\n\t  firstChild();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\texports.elementOpenStart = function (tag, key, statics) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    setInAttributes();\n\t  }\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\texports.attr = function (name, value) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t  }\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpenEnd = function () {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t    setNotInAttributes();\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementClose = function (tag) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    assertCloseMatchesOpenTag(tag);\n\t  }\n\t\n\t  parentNode();\n\t\n\t  var node = /** @type {!Element} */getContext().walker.currentNode;\n\t\n\t  clearUnvisitedDOM(node);\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementVoid = function (tag, key, statics, var_args) {\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementPlaceholder = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertPlaceholderKeySpecified(key);\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  updateAttribute(node, exports.symbols.placeholder, true);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} var_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\texports.text = function (value, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      formatted = arguments[i](formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar style = function(getter) {\n\t  return function() {\n\t    var data = getter.apply(this, arguments);\n\t    if (data && typeof data === 'object') {\n\t      return formatStyle(data);\n\t    }\n\t    return data;\n\t  };\n\t};\n\t\n\tvar className = function(getter) {\n\t  return function() {\n\t    var data = getter.apply(this, arguments);\n\t    if (data && typeof data === 'object') {\n\t      return formatClassName(data);\n\t    }\n\t    return data;\n\t  };\n\t};\n\t\n\tmodule.exports = {\n\t  style: style,\n\t  className: className\n\t};\n\t\n\tfunction formatStyle(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join('; ');\n\t  }\n\t  return Object.keys(obj)\n\t    .map(function(key) {\n\t      return [\n\t        reformatCamelCase(key),\n\t        ': ',\n\t        obj[key],\n\t        ';'\n\t      ].join('');\n\t    })\n\t    .join(' ');\n\t}\n\t\n\tfunction reformatCamelCase(str) {\n\t  return str.replace(/[A-Z]/g, function(char) {\n\t    return '-' + char.toLowerCase();\n\t  });\n\t}\n\t\n\tfunction formatClassName(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t  return Object.keys(obj).filter(function(key) {\n\t    return !!obj[key];\n\t  }).join(' ');\n\t}\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0c53c91c559b76c4bbc9\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar render = require('./render');\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: render.create,\n  render: render.render\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*! (C) WebReflection Mit Style License */\n(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/document-register-element/build/document-register-element.js\n ** module id = 1\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render').create;\n\nvar RENDER = '__render';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        console.log('attached!', this);\n        this.update();\n      }},\n\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      render: {value: function(data) {\n        if (!arguments.length) data = this.data;\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      invalidate: {value: function() {\n        this[RENDER] = null;\n        this.render();\n      }},\n\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function property(read, write, value) {\n  return {\n    enumerable: false,\n\n    get: function() {\n      return read ? read.call(this, value) : value;\n    },\n\n    set: function(v) {\n      if (v !== value) {\n        var previous = value;\n        return value = write.call(this, v, previous);\n      }\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 3\n ** module chunks = 0\n **/","var arrow = require('./arrow');\n\nvar evaluate = function(expression, context) {\n  var fn = evaluator(expression);\n  return fn.call(this, context);\n};\n\nvar evaluator = function(expression) {\n  if (arrow.is(expression)) {\n    return parseArrow(expression);\n  }\n\n  var symbol = 'd' + Date.now();\n  // '.' is just the identity function\n  if (expression === '.') {\n    return function identity(d) { return d; };\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    'with (', symbol, ' || {}) {',\n    '  return ', expression, ';',\n    '} ',\n    '} catch (error) { }'\n  ].join(''));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator,\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 4\n ** module chunks = 0\n **/","var ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = match[4] || match[5];\n  return new Function(args, 'return (' + body + ')');\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 5\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar incremental = require('incremental-dom');\nvar xp = require('./evaluate');\nvar transform = require('./transform');\n\nvar T_NAMESPACE = 't-';\nvar T_IF = T_NAMESPACE + 'if';\nvar T_ELSE = T_NAMESPACE + 'else';\nvar T_EACH = T_NAMESPACE + 'each';\nvar T_TEXT = T_NAMESPACE + 'text';\nvar T_FOREACH = T_NAMESPACE + 'foreach';\n\nvar CONTROL_ATTRS = [T_IF, T_ELSE, T_EACH, T_FOREACH, T_TEXT];\n\nvar VOID_ELEMENTS = [\n  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n  'wbr'\n];\n\nmodule.exports = {\n  create: createRenderFunction,\n  render: function(root, data) {\n    var render = createRenderFunction(root);\n    render(data);\n    return render;\n  }\n};\n\nfunction createRenderFunction(root) {\n  if (typeof root === 'string') {\n    var selector = root;\n    root = document.querySelector(selector);\n    if (!root) {\n      throw new Error('no element found with selector: \"' + selector + '\"');\n    }\n  }\n  var render = createRenderer(root);\n  return function _render(data) {\n    // console.log('rendering with data:', data);\n    return incremental.patch(root, render.bind(this, data));\n  };\n}\n\nfunction createRenderer(root) {\n  var calls = [];\n  for (\n    var child = root.firstChild; child;\n    child = child.nextSibling\n  ) {\n    switch (child.nodeType) {\n      case Node.TEXT_NODE:\n        calls.push(createTextRenderer(child));\n        break;\n      case Node.ELEMENT_NODE:\n        calls.push(createElementRenderer(child));\n        break;\n    }\n  }\n  return function patch(data) {\n    // console.log('patching:', root, 'with', data);\n    calls.forEach(function(fn) {\n      fn(data);\n    });\n  };\n}\n\nfunction createTextRenderer(node) {\n  // TODO: expand {{ expressions }} ?\n  return function(data) {\n    incremental.text(node.nodeValue);\n  };\n}\n\nfunction createElementRenderer(node) {\n  var name = node.nodeName.toLowerCase();\n\n  var isVoid = isElementVoid(name);\n  var attrMap = getAttributeMap(node);\n\n  var condition = node.hasAttribute(T_IF)\n    ? xp.evaluator(node.getAttribute(T_IF))\n    : null;\n\n  if (node.hasAttribute(T_ELSE)) {\n    if (condition) throw new Error('element has both t-if and t-else attributes');\n    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n    if (!ifSibling) throw new Error('element with t-else has no matching t-if sibling');\n    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n  }\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  var textExpression = node.getAttribute(T_TEXT);\n  if (textExpression) {\n    var getText = xp.evaluator(textExpression);\n    renderChildren = function(data) {\n      var value = getText(data);\n      if (defined(value)) {\n        incremental.text(String(value));\n      }\n    };\n  } else {\n    renderChildren = createRenderer(node);\n  }\n\n  var render = function(data) {\n    // console.log('rendering', node, 'with data:', data);\n    if (condition && !condition(data)) {\n      return false;\n    }\n\n    var attrs = interpolateAttributes(attrMap, data);\n    if (isVoid) {\n      incremental.elementVoid(name, '', attrs);\n    } else {\n      incremental.elementOpen(name, '', attrs);\n      renderChildren(data);\n      incremental.elementClose(name);\n    }\n  };\n\n  var eachExpression = node.getAttribute(T_EACH);\n  var forEachExpression = node.getAttribute(T_FOREACH);\n\n  // <ul><li t-each=\"items\">{{ . }}</li></ul>\n  if (eachExpression) {\n    // console.info('render each:', node, eachExpression);\n    render = renderEach(eachExpression, render);\n  // <ul t-foreach=\"items\"><li>{{ . }}</li></ul>\n  } else if (forEachExpression) {\n    // console.info('render foreach:', node, forEachExpression);\n    renderChildren = renderEach(forEachExpression, renderChildren);\n  } else {\n    // console.info('render once:', node);\n  }\n\n  return render;\n}\n\nfunction renderEach(expression, render) {\n  return function(data) {\n    var values = xp.evaluate(expression, data);\n    forEach(values, render);\n  };\n}\n\nfunction getAttributeMap(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = String(attr.name);\n    if (CONTROL_ATTRS.indexOf(name) > -1) {\n      // console.info('skipping control attribute', name, 'for', node);\n      continue;\n    } else if (name.indexOf(T_NAMESPACE) === 0) {\n      var getter = xp.evaluator(attr.value);\n      name = name.substr(T_NAMESPACE.length);\n      switch (name) {\n        case 'class':\n          getter = transform.className(getter);\n          break;\n        case 'style':\n          getter = transform.style(getter);\n          break;\n      }\n      map[name] = getter;\n    } else {\n      map[name] = attr.value;\n    }\n  }\n  return map;\n}\n\nfunction interpolateAttributes(attrMap, data) {\n  var attrs = [];\n  for (var key in attrMap) {\n    var value = attrMap[key];\n    if (typeof value === 'function') {\n      value = value.call(this, data, key);\n    }\n    if (defined(value)) {\n      attrs.push(key, value);\n    }\n  }\n  return attrs;\n}\n\nfunction getPreviousSibling(node, selector) {\n  while (node = node.previousSibling) {\n    if (!node) break;\n    if (node.matches(selector)) return node;\n  }\n  throw new Error('no previous sibling found matching: ' + selector);\n}\n\nfunction isElementVoid(name) {\n  return VOID_ELEMENTS.indexOf(name) > -1;\n}\n\nfunction forEach(data, fn) {\n  return data.forEach(fn, this);\n}\n\nfunction defined(value) {\n  return value !== null && value !== undefined;\n}\n\nfunction not(fn) {\n  return function() {\n    return !fn.apply(this, arguments);\n  };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 6\n ** module chunks = 0\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     walker should start traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /**\n   * @const {!Element|!DocumentFragment}\n   */\n  this.root = node;\n\n  /**\n   * @type {?Node}\n   */\n  this.currentNode = node;\n}\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function () {\n  return this.stack_[this.stack_.length - 1];\n};\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function () {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function () {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function () {\n  this.currentNode = this.stack_.pop();\n};\n\n/**\n * Keeps track of the state of a patch.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     is for.\n * @param {?Context} prevContext The previous context.\n * @constructor\n */\nfunction Context(node, prevContext) {\n  /**\n   * @const {TreeWalker}\n   */\n  this.walker = new TreeWalker(node);\n\n  /**\n   * @const {Document}\n   */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @private\n   * @const {!Array<(string|undefined)>}\n   */\n  this.nsStack_ = [undefined];\n\n  /**\n   * @const {?Context}\n   */\n  this.prevContext = prevContext;\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n/**\n * @return {(string|undefined)} The current namespace to create Elements in.\n */\nContext.prototype.getCurrentNamespace = function () {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n/**\n * @param {string=} namespace The namespace to enter.\n */\nContext.prototype.enterNamespace = function (namespace) {\n  this.nsStack_.push(namespace);\n};\n\n/**\n * Exits the current namespace\n */\nContext.prototype.exitNamespace = function () {\n  this.nsStack_.pop();\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * The current context.\n * @type {?Context}\n */\nvar context;\n\n/**\n * Enters a new patch context.\n * @param {!Element|!DocumentFragment} node\n */\nvar enterContext = function (node) {\n  context = new Context(node, context);\n};\n\n/**\n * Restores the previous patch context.\n */\nvar restoreContext = function () {\n  context = context.prevContext;\n};\n\n/**\n * Gets the current patch context.\n * @return {?Context}\n */\nvar getContext = function () {\n  return context;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * @type {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {string|Object<string,string>} style The style to set. Either a\n *     string of css or an object containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n\n    for (var prop in style) {\n      if (has(style, prop)) {\n        elStyle[prop] = style[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function () {};\n\nexports.attributes['style'] = applyStyle;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function (tag) {\n  if (tag === 'svg') {\n    getContext().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getContext().enterNamespace(undefined);\n  }\n};\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function (tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getContext().exitNamespace();\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {(string|undefined)} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getContext().getCurrentNamespace();\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function (doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Node} parent\n * @param {?string=} key\n * @return {?Element} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n  );\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!Element} node The node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function (node, tag, key) {\n    var nodeName = getData(node).nodeName;\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n    }\n  };\n}\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key && nodeName === data.nodeName;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  var context = getContext();\n  var walker = context.walker;\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(existingNode, nodeName, key);\n      }\n\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(context.doc, nodeName, key, statics);\n\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n\n      context.markCreated(matchingNode);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      parent.replaceChild(matchingNode, currentNode);\n      getData(parent).keyMapValid = false;\n    } else {\n      parent.insertBefore(matchingNode, currentNode);\n    }\n\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {Node} node\n */\nvar clearUnvisitedDOM = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var lastVisitedChild = data.lastVisitedChild;\n  var child = node.lastChild;\n  var key;\n\n  data.lastVisitedChild = null;\n\n  if (child === lastVisitedChild && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n    return;\n  }\n\n  while (child !== lastVisitedChild) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  for (key in keyMap) {\n    child = keyMap[key];\n    if (!child.parentNode) {\n      context.markDeleted(child);\n      delete keyMap[key];\n    }\n  }\n\n  data.keyMapValid = true;\n};\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {Node} node\n */\nvar enterNode = function (node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {Node} node\n */\nvar exitNode = function (node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n/**\n * Marks node's parent as having visited node.\n * @param {Node} node\n */\nvar markVisited = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function () {\n  var context = getContext();\n  var walker = context.walker;\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function () {\n  var context = getContext();\n  var walker = context.walker;\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function () {\n  var context = getContext();\n  var walker = context.walker;\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function (root) {\n    var openElement = getContext().walker.getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n  };\n}\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function (node, fn, data) {\n  enterContext(node);\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  getContext().notifyChanges();\n  restoreContext();\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function () {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n    }\n  };\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function () {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n    }\n  };\n\n  /**\n   * Makes sure that placeholders have a key specified. Otherwise, conditional\n   * placeholders and conditional elements next to placeholders will cause\n   * placeholder elements to be re-used as non-placeholders and vice versa.\n   * @param {string} key\n   */\n  var assertPlaceholderKeySpecified = function (key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function (tag) {\n    var context = getContext();\n    var walker = context.walker;\n    var closingNode = walker.getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n    }\n  };\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function () {\n    inAttributes = true;\n  };\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function () {\n    inAttributes = false;\n  };\n}\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var attr,\n        newAttrs = data.newAttrs;\n\n    for (attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = /** @type {!Element} */getContext().walker.currentNode;\n\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function (tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  var node = exports.elementOpen.apply(null, arguments);\n  updateAttribute(node, exports.symbols.placeholder, true);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n  return node;\n};\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/dist/incremental-dom-cjs.js\n ** module id = 7\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 8\n ** module chunks = 0\n **/","var style = function(getter) {\n  return function() {\n    var data = getter.apply(this, arguments);\n    if (data && typeof data === 'object') {\n      return formatStyle(data);\n    }\n    return data;\n  };\n};\n\nvar className = function(getter) {\n  return function() {\n    var data = getter.apply(this, arguments);\n    if (data && typeof data === 'object') {\n      return formatClassName(data);\n    }\n    return data;\n  };\n};\n\nmodule.exports = {\n  style: style,\n  className: className\n};\n\nfunction formatStyle(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join('; ');\n  }\n  return Object.keys(obj)\n    .map(function(key) {\n      return [\n        reformatCamelCase(key),\n        ': ',\n        obj[key],\n        ';'\n      ].join('');\n    })\n    .join(' ');\n}\n\nfunction reformatCamelCase(str) {\n  return str.replace(/[A-Z]/g, function(char) {\n    return '-' + char.toLowerCase();\n  });\n}\n\nfunction formatClassName(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n  return Object.keys(obj).filter(function(key) {\n    return !!obj[key];\n  }).join(' ');\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/transform.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}
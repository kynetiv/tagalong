{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap c752303c182827b82f46","webpack:///./src/main.js","webpack:///./~/document-register-element/build/document-register-element.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/render.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./src/transform.js","webpack:///./src/interpolate.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Template","render","window","tagalong","createRenderer","create","e","t","n","r","rt","length","dt","it","nt","b","ot","st","j","querySelectorAll","w","getAttribute","nodeName","toUpperCase","S","y","v","d","ut","indexOf","at","currentTarget","attrChange","attrName","i","target","Q","attributeChangedCallback","a","prevValue","l","newValue","ft","X","push","lt","K","removeEventListener","h","detail","o","s","B","pt","ct","this","q","G","ht","D","et","observe","z","J","setAttribute","Z","addEventListener","createdCallback","created","F","E","contains","splice","tt","Y","Math","random","u","f","g","documentElement","x","prototype","T","hasOwnProperty","N","isPrototypeOf","C","defineProperty","k","getOwnPropertyDescriptor","L","getOwnPropertyNames","A","getPrototypeOf","O","setPrototypeOf","M","__proto__","_","vt","P","MutationObserver","WebKitMutationObserver","H","HTMLElement","Element","Node","nodeType","I","cloneNode","R","removeAttribute","U","createElement","attributes","characterData","attributeOldValue","W","V","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","$","value","CustomEvent","bubbles","dispatchEvent","hasAttribute","propertyName","name","className","type","addedNodes","removedNodes","attributeName","oldValue","childList","subtree","shift","apply","arguments","toLowerCase","innerHTMLHelper","Error","test","concat","document","Object","property","evaluate","RENDER","DATA_ATTR","registerElement","attachedCallback","console","log","update","attr","previous","expr","data","invalidate","read","write","enumerable","get","set","arrow","expression","fn","evaluator","is","parseArrow","symbol","Date","now","match","Function","join","ARROW_PATTERN","isArrow","String","args","body","parse","createRenderFunction","root","context","selector","querySelector","incremental","patch","bind","calls","child","firstChild","nextSibling","TEXT_NODE","createTextRenderer","ELEMENT_NODE","createElementRenderer","forEach","node","template","nodeValue","text","interpolate","defined","T_SKIP","noop","isVoid","isElementVoid","attrMap","getAttributeMap","condition","T_IF","xp","T_ELSE","ifSibling","getPreviousSibling","not","renderChildren","textExpression","T_TEXT","getText","attrs","interpolateAttributes","elementVoid","elementOpen","elementClose","eachExpression","T_EACH","forEachExpression","T_FOREACH","withExpression","T_WITH","T_AS","renderEach","renderWith","symbolSetter","values","map","T_NS","substr","CONTROL_ATTRS","getter","transform","style","key","previousSibling","matches","VOID_ELEMENTS","iterate","Array","isArray","split","undefined","process","TreeWalker","stack_","currentNode","Context","prevContext","walker","doc","ownerDocument","nsStack_","notifications","nodesCreated","deleted","nodesDeleted","NodeData","createMap","attrsArr","newAttrs","keyMap","keyMapValid","lastVisitedChild","getCurrentParent","parentNode","pop","getCurrentNamespace","enterNamespace","namespace","exitNamespace","markCreated","markDeleted","notifyChanges","enterContext","restoreContext","getContext","has","initData","getData","symbols","default","placeholder","applyAttr","el","applyProp","applyStyle","cssText","elStyle","prop","applyAttributeTyped","updateAttribute","mutator","SVG_NS","enterTag","tag","exitTag","getNamespaceForTag","statics","createElementNS","createNode","createTextNode","createKeyMap","children","count","getKeyMap","getChild","parent","registerChild","env","NODE_ENV","assertKeyedTagMatches","alignWithDOM","matchingNode","existingNode","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","enterNode","exitNode","markVisited","assertNoUnclosedTags","openElement","openTags","ATTRIBUTES_OFFSET","argsBuilder","inAttributes","assertNotInAttributes","assertInAttributes","assertPlaceholderKeySpecified","assertCloseMatchesOpenTag","closingNode","setInAttributes","setNotInAttributes","var_args","attrsChanged","elementOpenStart","elementOpenEnd","elementPlaceholder","formatted","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","clearTimeout","Item","fun","array","nextTick","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","formatStyle","obj","keys","reformatCamelCase","str","replace","char","formatClassName","filter","that"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GE5ChCA,EAAA,EAEA,IAAAW,GAAAX,EAAA,GACAY,EAAAZ,EAAA,EAEAa,QAAAC,UACAH,WACAI,eAAAH,EAAAI,OACAJ,kBFoDM,SAASR,EAAQD;CG3DvB,SAAAc,EAAAC,EAAAC,EAAAC,GAAmB,YAAa,SAAAC,GAAAJ,EAAAC,GAAiB,OAAAC,GAAA,EAAAC,EAAAH,EAAAK,OAAuBF,EAAAD,EAAIA,IAAAI,EAAAN,EAAAE,GAAAD,GAAe,QAAAM,GAAAP,GAAe,OAAAG,GAAAF,EAAA,EAAAC,EAAAF,EAAAK,OAAyBH,EAAAD,EAAIA,IAAAE,EAAAH,EAAAC,GAAAO,EAAAL,EAAAM,EAAAC,EAAAP,KAA0B,QAAAQ,GAAAX,GAAe,gBAAAC,GAAmBW,GAAAX,KAAAK,EAAAL,EAAAD,GAAAI,EAAAH,EAAAY,iBAAAC,GAAAd,KAA6C,QAAAU,GAAAV,GAAe,GAAAC,GAAAD,EAAAe,aAAA,MAAAb,EAAAF,EAAAgB,SAAAC,cAAAd,EAAAe,EAAA5B,KAAA6B,EAAAlB,EAAAmB,EAAAnB,EAAAgB,cAAAI,EAAAnB,EAA0F,OAAAD,IAAAE,EAAA,KAAAmB,EAAApB,EAAAD,GAAA,GAAAE,EAA8B,QAAAmB,GAAAtB,EAAAC,GAAiB,SAAAa,EAAAS,QAAAvB,EAAA,QAAAC,EAAA,MAAqC,QAAAuB,GAAAxB,GAAe,GAAAC,GAAAD,EAAAyB,cAAAvB,EAAAF,EAAA0B,WAAAvB,EAAAH,EAAA2B,SAAAC,EAAA5B,EAAA6B,MAA6DC,OAAAF,OAAA3B,MAAA8B,0BAAA,UAAA5B,GAAAF,EAAA8B,yBAAA5B,EAAAD,IAAAF,EAAAgC,GAAA,KAAAhC,EAAAiC,UAAA/B,IAAAF,EAAAkC,GAAA,KAAAlC,EAAAmC,UAA0I,QAAAC,GAAApC,GAAe,GAAAC,GAAAU,EAAAX,EAAY,iBAAAA,GAAmBqC,EAAAC,KAAArC,EAAAD,EAAA6B,SAAoB,QAAAU,GAAAvC,GAAewC,SAAA,EAAAxC,EAAAyB,cAAAgB,oBAAAC,EAAAH,IAAAnC,GAAAJ,EAAA6B,QAAA5B,GAAAY,iBAAAC,GAAAd,EAAA2C,SAAAC,IAAAC,GAAAC,IAAAC,IAAmH,QAAAC,GAAAhD,EAAAC,GAAiB,GAAAC,GAAA+C,IAAWC,IAAA5D,KAAAY,EAAAF,EAAAC,GAAAkD,EAAA7D,KAAAY,GAAwB2B,OAAA3B,IAAW,QAAAkD,GAAApD,EAAAC,GAAiBoD,EAAArD,EAAAC,GAAAqD,IAAAC,QAAAvD,EAAAwD,KAAAC,KAAAzD,EAAA0D,aAAAV,EAAAhD,EAAA4B,GAAA+B,EAAA3D,KAAA4D,iBAAAnE,EAAA0D,IAAAnD,EAAA4D,iBAAApE,EAAAgC,IAAAxB,EAAA6D,iBAAA/B,KAAA9B,EAAA8D,SAAA,EAAA9D,EAAA6D,kBAAA7D,EAAA8D,SAAA,GAAoL,QAAAf,KAAc,OAAA/C,GAAAC,EAAA,EAAAC,EAAA6D,GAAA1D,OAAyBH,EAAAD,EAAIA,IAAAD,EAAA+D,GAAA9D,GAAA+D,EAAAC,SAAAjE,KAAA+D,GAAAG,OAAAjE,EAAA,GAAAK,EAAAN,EAAA4C,IAAkD,QAAAtC,GAAAN,EAAAC,GAAiB,GAAAC,GAAAC,EAAAO,EAAAV,EAAcG,GAAA,KAAAgE,EAAAnE,EAAAS,EAAAN,MAAA,EAAAF,IAAA4C,GAAA7C,EAAA6C,GAAA5C,IAAA2C,IAAA5C,EAAA4C,KAAA5C,EAAA6C,IAAA,EAAA7C,EAAA4C,IAAA,EAAAzC,EAAA,IAAAH,EAAA4C,IAAA,EAAA5C,EAAA6C,IAAA,EAAA1C,EAAA,EAAA2C,IAAA5B,EAAA5B,KAAAyE,GAAA/D,GAAA,GAAA+D,GAAAzB,KAAAtC,IAAAG,IAAAD,EAAAF,EAAAC,EAAA,cAAAC,EAAAZ,KAAAU,IAA4J,KAAAG,IAAAF,IAAA,CAAiB,GAA40CoC,GAAiJc,EAAAiB,EAAAT,EAAAL,EAAAa,EAAA3D,EAA79CoB,EAAA,KAAAzB,GAAA,IAAAkE,KAAAC,UAAA,GAAAzB,EAAA,WAAAD,EAAA,WAAA2B,EAAA,UAAAvC,EAAA,WAAAwC,EAAA,eAAAtC,EAAA,UAAA1C,EAAA,kBAAAkD,EAAA,mBAAAjD,EAAA,qBAAA4B,EAAA,IAAAD,EAAA,IAAA7B,EAAA,kCAAAkF,GAAA,kIAAAtD,KAAAV,KAAAK,EAAA,GAAAkD,EAAA/D,EAAAyE,gBAAAxD,EAAAC,EAAAI,SAAA,SAAAvB,GAAqa,OAAAC,GAAAgD,KAAA5C,OAAsBJ,KAAAgD,KAAAhD,KAAAD,IAAmB,MAAAC,IAAS0E,EAAAzE,EAAA0E,UAAAC,EAAAF,EAAAG,eAAAC,EAAAJ,EAAAK,cAAAC,EAAA/E,EAAAgF,eAAAC,EAAAjF,EAAAkF,yBAAAC,EAAAnF,EAAAoF,oBAAAC,EAAArF,EAAAsF,eAAAC,EAAAvF,EAAAwF,eAAAC,IAAAzF,EAAA0F,UAAAC,EAAA3F,EAAAH,QAAA,QAAA+F,IAAA9F,GAA6M,MAAAA,IAAA8F,GAAAlB,UAAA5E,EAAA,GAAA8F,KAAA7C,MAAsCI,EAAAoC,IAAAE,EAAA,SAAA3F,EAAAC,GAAuB,MAAAD,GAAA4F,UAAA3F,EAAAD,GAAuBqF,GAAAF,EAAA,WAAiB,QAAAnF,KAAAC,GAAgB,OAAAC,GAAAC,EAAAkF,EAAApF,GAAA2B,EAAA,EAAAiB,EAAA1C,EAAAE,OAAgCwC,EAAAjB,EAAIA,IAAA1B,EAAAC,EAAAyB,GAAAiD,EAAAvF,KAAAU,EAAAE,IAAA+E,EAAAjF,EAAAE,EAAAiF,EAAAlF,EAAAC,IAAsC,gBAAAD,EAAAC,GAAqB,EAAAF,GAAAC,EAAAC,UAAUA,EAAAqF,EAAArF,MAAA6E,EAAAzF,KAAAY,EAAAD,GAA8B,OAAAA,OAAU,SAAAD,EAAAC,GAAiB,OAAAC,KAAAD,GAAAD,EAAAE,GAAAD,EAAAC,EAAyB,OAAAF,KAAS+F,EAAA/F,EAAAgG,kBAAAhG,EAAAiG,uBAAAC,IAAAlG,EAAAmG,aAAAnG,EAAAoG,SAAApG,EAAAqG,MAAAzB,UAAA9B,IAAAiC,EAAAzF,KAAA4G,GAAAlC,GAAApD,GAAAkC,GAAA,SAAA9C,GAA+H,WAAAA,EAAAsG,UAAsB,SAAAtG,GAAa,MAAA+E,GAAAzF,KAAA4G,GAAAlG,IAAmB+D,GAAAjB,OAAAyD,GAAAL,GAAAM,UAAAtD,GAAAgD,GAAAxC,aAAA+C,GAAAP,GAAAQ,gBAAAC,GAAA1G,EAAA2G,cAAApD,GAAAuC,IAAoFc,YAAA,EAAAC,eAAA,EAAAC,mBAAA,GAAoDC,GAAAjB,GAAA,SAAA/F,GAAkByD,IAAA,EAAAO,EAAAvB,oBAAAjD,EAAAwH,KAAgCC,GAAAjH,EAAAkH,uBAAAlH,EAAAmH,6BAAAnH,EAAAoH,0BAAApH,EAAAqH,yBAAA,SAAArH,GAAgIsH,WAAAtH,EAAA,KAAiBuH,IAAA,EAAA9D,IAAA,EAAAjB,IAAA,EAAAV,IAAA,CAAoC2D,IAAAE,GAAAxB,EAAA,SAAAnE,EAAAC,GAAuB8E,EAAAzF,KAAAW,EAAAD,IAAAoD,EAAApD,EAAAC,IAAqBO,EAAA4C,IAAAe,EAAA,SAAAnE,EAAAC,GAA0BD,EAAA4B,KAAA5B,EAAA4B,GAAA1B,GAAA,GAAAkD,EAAApD,EAAAC,KAA2BO,EAAA2D,GAAArB,IAAAW,IAAA,aAA2B,GAAAzD,GAAAmF,EAAAe,GAAA,oBAAAjG,EAAAD,EAAAwH,MAAAtH,EAAA,SAAAF,GAAsD,GAAAC,GAAA,GAAAwH,aAAAjI,GAAyBkI,SAAA,GAAazH,GAAA0B,SAAA3B,EAAAC,EAAAgC,UAAAgB,KAAAlC,aAAAf,GAAAC,EAAAkC,SAAA,KAAAlC,EAAAiC,GAAAjC,EAAAyB,WAAA,EAAA+E,GAAAnH,KAAA2D,KAAAjD,GAAAiD,KAAA0E,cAAA1H,IAAuHE,EAAA,SAAAH,EAAAC,GAAiB,GAAAC,GAAA+C,KAAA2E,aAAA5H,GAAAG,EAAAD,GAAA+C,KAAAlC,aAAAf,GAAA4B,EAAA,GAAA6F,aAAAjI,GAA0EkI,SAAA,GAAaxE,IAAA5D,KAAA2D,KAAAjD,EAAAC,GAAA2B,EAAAD,SAAA3B,EAAA4B,EAAAK,UAAA/B,EAAAC,EAAA,KAAAyB,EAAAO,SAAAlC,EAAAC,EAAA0B,EAAA4C,GAAA5C,EAAAF,WAAA,EAAAE,EAAAI,GAAAJ,EAAAF,WAAA,EAAAuB,KAAA0E,cAAA/F,IAAgIiB,EAAA,SAAA7C,GAAe,GAAA6C,GAAA5C,EAAAD,EAAAyB,cAAAvB,EAAAD,EAAA2B,GAAAzB,EAAAH,EAAA6H,YAAgD3H,GAAA4E,eAAA3E,KAAAD,IAAAC,GAAA0C,EAAA,GAAA4E,aAAAjI,GAAkDkI,SAAA,IAAW7E,EAAAlB,SAAAzB,EAAA4H,KAAAjF,EAAAZ,UAAA/B,EAAAsH,OAAA,KAAA3E,EAAAV,SAAAjC,EAAAsH,MAAAvH,EAAAE,IAAA,WAAA0C,EAAAZ,UAAAY,EAAAb,GAAAa,EAAAnB,WAAA,EAAAmB,EAAA2B,GAAA3B,EAAAnB,WAAA,EAAAzB,EAAA0H,cAAA9E,IAA2J7C,GAAAwH,MAAA,SAAAxH,EAAA4C,EAAA2B,GAAwBvE,IAAAR,GAAAyD,KAAAlB,0BAAAkB,KAAAS,eAAAvD,IAAA8C,KAAArB,IAAuEmG,WAAWD,KAAA,QAAAN,MAAAvE,KAAA8E,YAAmC9E,KAAAS,aAAAvD,EAAA8C,KAAAyD,gBAAAxG,EAAAD,EAAAX,KAAA2D,KAAA,iBAAAJ,IAAA5C,EAAAX,KAAA2D,KAAAjD,EAAA4C,EAAA2B,IAAgGU,EAAAiB,GAAA,mBAAAlG,OAA2B+F,IAAA/B,EAAAJ,iBAAApE,EAAAwH,IAAAhD,EAAAN,aAAA9B,EAAA,GAAAoC,EAAA0C,gBAAA9E,GAAA6B,KAAAN,EAAA,SAAAnD,GAA2F,GAAAE,GAAAC,EAAA0C,EAAA5C,EAAAgD,IAAiB,IAAAhD,IAAAD,EAAA6B,OAAA,CAAiB3B,EAAAD,EAAA2B,GAAA3B,EAAA2B,GAAAzB,EAAAwD,EAAA1D,EAAmB,KAAA4C,IAAA1C,GAAA,CAAY,KAAA0C,IAAA3C,IAAA,MAAAkE,GAAA,EAAAnE,EAAA4C,EAAA3C,EAAA2C,GAAA1C,EAAA0C,GAAAb,EAAyC,IAAA7B,EAAA0C,KAAA3C,EAAA2C,GAAA,MAAAuB,GAAA,EAAAnE,EAAA4C,EAAA3C,EAAA2C,GAAA1C,EAAA0C,GAAA2B,GAA2C,IAAA3B,IAAA3C,GAAA,KAAA2C,IAAA1C,IAAA,MAAAiE,GAAA,EAAAnE,EAAA4C,EAAA3C,EAAA2C,GAAA1C,EAAA0C,GAAAX,KAAqDkC,EAAA,SAAApE,EAAAC,EAAAC,EAAAC,EAAAyB,EAAAiB,GAAyB,GAAAD,IAAOlB,WAAA1B,EAAAyB,cAAAxB,EAAA0B,SAAAzB,EAAA+B,UAAA9B,EAAAgC,SAAAP,EAAgEgB,GAAAC,GAAA7C,EAAAwB,EAAAoB,IAAae,EAAA,SAAA3D,GAAe,OAAAC,GAAAC,EAAAC,KAAgByB,EAAA5B,EAAA6G,WAAAhE,EAAA,EAAAD,EAAAhB,EAAAvB,OAA+BuC,EAAAC,EAAIA,IAAA5C,EAAA2B,EAAAiB,GAAA3C,EAAAD,EAAA6H,KAAA,iBAAA5H,IAAAC,EAAAD,GAAAD,EAAAuH,MAAuD,OAAArH,MAASF,EAAAE,GAAA,SAAAD,EAAAC,GAA2hC,GAArgCV,EAAAS,EAAAe,cAAAsG,SAAA,EAAAxB,GAAAzC,EAAA,SAAAtD,EAAAC,GAA+C,QAAAC,GAAAF,EAAAC,GAAgB,OAAAC,GAAA,EAAAC,EAAAH,EAAAK,OAAuBF,EAAAD,EAAID,EAAAD,EAAAE,QAAY,UAAA6F,GAAA,SAAA5F,GAAyB,OAAAyB,GAAAiB,EAAAD,EAAA,EAAA2B,EAAApE,EAAAE,OAA2BkE,EAAA3B,EAAIA,IAAAhB,EAAAzB,EAAAyC,GAAA,cAAAhB,EAAAoG,MAAA9H,EAAA0B,EAAAqG,WAAAjI,GAAAE,EAAA0B,EAAAsG,aAAAjI,KAAA4C,EAAAjB,EAAAC,OAAAC,IAAAe,EAAAd,0BAAA,UAAAH,EAAAuG,eAAAtF,EAAAd,yBAAAH,EAAAuG,cAAAvG,EAAAwG,SAAAvF,EAAA9B,aAAAa,EAAAuG,oBAAwOxH,EAAAkC,GAAAlC,EAAAiC,IAAAU,EAAAC,QAAAtD,GAA4BoI,WAAA,EAAAC,SAAA,MAAwBjG,KAAA4E,GAAA,QAAAjD,KAAwB,KAAA3B,EAAAhC,QAAAgC,EAAAkG,QAAAjJ,KAAA,KAAA+C,EAAAkG,QAA8CtB,IAAAjD,KAAK/D,EAAA2D,iBAAA,kBAAAxB,EAAAS,IAAA5C,EAAA2D,iBAAA,iBAAAxB,EAAAQ,KAAA3C,EAAA2D,iBAAAlB,EAAAH,GAAAtC,EAAA2D,iBAAA,mBAAArB,GAAAtC,EAAA2G,cAAA,SAAA5G,EAAAE,GAA2L,GAAAC,GAAAwG,GAAA6B,MAAAvI,EAAAwI,WAAA7G,EAAA,GAAA5B,EAAA6C,EAAA3B,EAAA5B,KAAA6B,GAAAjB,EAAAkB,EAAAC,IAAAnB,GAAA0B,GAAAX,eAAA2B,EAAAC,EAAA,EAAkF,OAAA3C,KAAAC,EAAAuD,aAAA,KAAAxD,IAAAwI,eAAA9F,MAAAtB,EAAAM,EAAAX,cAAAf,KAAA4B,IAAA7B,EAAA2G,cAAA+B,gBAAA/F,GAAApC,EAAAL,EAAAM,EAAAoC,IAAA1C,GAAmI+F,GAAAM,UAAA,SAAAxG,GAAyB,GAAAC,GAAAsG,GAAAjH,KAAA2D,OAAAjD,GAAAE,EAAAQ,EAAAT,EAA+B,OAAAC,GAAA,IAAAM,EAAAP,EAAAQ,EAAAP,IAAAF,GAAAO,EAAAN,EAAAY,iBAAAC,IAAAb,IAAwD,GAAAiB,EAAA5B,KAAA6B,EAAAC,EAAA3B,GAAAyB,EAAA5B,KAAA6B,EAAAE,EAAA5B,GAAA,SAAAmJ,OAAA,KAAA1I,EAAA,8BAAwF,KAAAX,EAAAsJ,KAAApJ,IAAA,GAAAyB,EAAA5B,KAAAmF,EAAAhF,GAAA,SAAAmJ,OAAA,YAAA1I,EAAA,cAA2E,IAAkET,GAAlEmC,EAAA,WAAiB,MAAA4C,GAAAvE,EAAA2G,cAAA1E,EAAAzC,GAAAQ,EAAA2G,cAAA1E,IAAiDF,EAAA7B,GAAAwE,EAAAH,EAAAK,EAAAvF,KAAA0C,EAAAuC,GAAArC,EAAAsC,EAAArE,EAAAoE,GAAAtD,cAAAxB,EAAAD,EAAA2B,EAAAmB,MAAAkC,EAAApD,EAAAC,GAAA5B,GAAA,CAAuE,OAAAqB,KAAAgI,OAAAhI,EAAAT,OAAA,OAAAmE,EAAAtC,EAAA,QAAAhC,EAAAwI,cAAA,KAAAxG,GAAAN,EAAAgD,UAAAnE,EAAAjB,GAAAqF,EAAAvF,KAAA0C,EAAA,aAAAA,EAAA4C,UAAAiB,EAAAK,IAAA9F,EAAAH,EAAAY,iBAAAC,GAAA+B,GAAAjB,KAA6JhC,OAAAmJ,SAAAC,OAAA,oBHkE77L,SAAS7J,EAAQD,EAASH,GInEhC,GAAAkK,GAAAlK,EAAA,GACAmK,EAAAnK,EAAA,GAAAmK,SACApJ,EAAAf,EAAA,GAAAgB,OAEAoJ,EAAA,WAEAC,EAAA,OAEA1J,EAAAqJ,SAAAM,gBAAA,cACAzE,UAAAoE,OAAAjJ,OACAoG,YAAAvB,WAEA0E,kBAAyB9B,MAAA,WACzB+B,QAAAC,IAAA,YAAAvG,MACAA,KAAAwG,WAGA1H,0BAAiCyF,MAAA,SAAAkC,EAAAlC,EAAAmC,GACjC,OAAAD,GACA,IAAAN,GACAnG,KAAAwG,YAKAA,QAAejC,MAAA,WAEf,GADA+B,QAAAC,IAAA,eACAvG,KAAA2E,aAAAwB,GAAA,CACA,GAAAQ,GAAA3G,KAAAlC,aAAAqI,GACAS,EAAAX,EAAAU,EACAL,SAAAC,IAAA,kBAAAI,EAAA,OAAAC,GACA5G,KAAA4G,UAIAlK,QAAe6H,MAAA,SAAAqC,GACfpB,UAAApI,SAAAwJ,EAAA5G,KAAA4G,KAEA,IAAAlK,GAAAsD,KAAAkG,EAMA,OALAxJ,KACAA,EAAAsD,KAAAkG,GAAArJ,EAAAmD,OAGAtD,EAAAkK,GACAA,IAGAC,YAAmBtC,MAAA,WACnBvE,KAAAkG,GAAA,KACAlG,KAAAtD,WAGAkK,KAAAZ,EACA,SAAAY,GACA,MAAAA,IAEA,SAAAA,EAAAF,GACA,MAAA1G,MAAAtD,OAAAkK,WAQA1K,GAAAD,QAAAQ,GJ0EM,SAASP,EAAQD,GK3IvBC,EAAAD,QAAA,SAAA6K,EAAAC,EAAAxC,GACA,OACAyC,YAAA,EAEAC,IAAA,WACA,MAAAH,KAAAzK,KAAA2D,KAAAuE,MAGA2C,IAAA,SAAA/I,GACA,GAAAA,IAAAoG,EAAA,CACA,GAAAmC,GAAAnC,CACA,OAAAA,GAAAwC,EAAA1K,KAAA2D,KAAA7B,EAAAuI,QLsJM,SAASxK,EAAQD,EAASH,GMjKhC,GAAAqL,GAAArL,EAAA,GAEAmK,EAAA,SAAAmB,EAAAR,GACA,GAAAS,GAAAC,EAAAF,EACA,OAAAC,GAAAhL,KAAA2D,KAAA4G,IAGAU,EAAA,SAAAF,GACA,GAAAD,EAAAI,GAAAH,GACA,MAAAI,YAAAJ,EAGA,IAAAK,GAAA,IAAAC,KAAAC,KAEA,aAAAP,EACA,SAAAhJ,GAAiC,MAAAA,KAE9BgJ,EAAAQ,MAAA,cACHR,EAAAK,EAAAL,GAEA,GAAAS,UAAAJ,GAEA,SACA,kBACA,aAAAA,EAAA,MACA,gBAAAL,EAAA,IACA,SACA,OACA,uBACAU,KAAA,MAGA5L,GAAAD,SACAgK,WACAqB,cNyKM,SAASpL,EAAQD,GO3MvB,GAAA8L,GAAA,8DAEAC,EAAA,SAAAZ,GACA,MAAAa,QAAAb,GAAAQ,MAAAG,IAGAP,EAAA,SAAAJ,GACA,GAAAQ,GAAAR,EAAAQ,MAAAG,EACA,KAAAH,EAAA,SAAAjC,OAAA,8BAAAyB,EAAA,IACA,IAAAc,GAAAN,EAAA,GACAO,EAAAP,EAAA,IAAAA,EAAA,EACA,WAAAC,UAAAK,EAAA,WAAAC,EAAA,KAGAjM,GAAAD,SACAsL,GAAAS,EACAI,MAAAZ,IPmNM,SAAStL,EAAQD,EAASH,GQvLhC,QAAAuM,GAAAC,EAAAC,GACA,mBAAAD,GAAA,CACA,GAAAE,GAAAF,CAEA,IADAA,EAAAxC,SAAA2C,cAAAD,IACAF,EACA,SAAA3C,OAAA,oCAAA6C,EAAA,KAGA,GAAA9L,GAAAG,EAAAyL,EAEA,OADA9C,WAAApI,OAAA,IAAAmL,MACA,SAAA3B,GAEA,MAAA8B,GAAAC,MAAAL,EAAA5L,EAAAkM,KAAAL,EAAA3B,KAIA,QAAA/J,GAAAyL,GAEA,IACA,GAFAO,MAEAC,EAAAR,EAAAS,WAAgCD,EAChCA,IAAAE,YAEA,OAAAF,EAAAzF,UACA,IAAAD,MAAA6F,UACAJ,EAAAxJ,KAAA6J,EAAAJ,GACA,MACA,KAAA1F,MAAA+F,aACAN,EAAAxJ,KAAA+J,EAAAN,IAIA,gBAAAlC,GAEAiC,EAAAQ,QAAA,SAAAhC,GACAA,EAAAhL,KAAA2D,KAAA4G,IACK5G,OAIL,QAAAkJ,GAAAI,GACA,GAAAC,GAAAD,EAAAE,SACA,iBAAA5C,GACA,GAAA6C,GAAAC,EAAArN,KAAA2D,KAAAuJ,EAAA3C,EACA8B,GAAAe,KAAAE,EAAAF,KAAA,KAIA,QAAAL,GAAAE,GACA,GAAAzE,GAAAyE,EAAAvL,SAAA0H,aAGA,IAAA6D,EAAA3E,aAAAiF,GACA,MAAAC,EAGA,IAAAC,GAAAC,EAAAlF,GACAmF,EAAAC,EAAAX,GAEAY,EAAAZ,EAAA3E,aAAAwF,GACAC,EAAA9C,UAAAgC,EAAAxL,aAAAqM,IACA,IAEA,IAAAb,EAAA3E,aAAA0F,GAAA,CACA,GAAAH,EAAA,SAAAvE,OAAA,8CACA,IAAA2E,GAAAC,EAAAjB,EAAA,IAAAa,EAAA,IACA,KAAAG,EAAA,SAAA3E,OAAA,mDACAuE,GAAAM,EAAAJ,EAAA9C,UAAAgD,EAAAxM,aAAAqM,KAGA,GAAAM,GAGAC,EAAApB,EAAAxL,aAAA6M,EACA,IAAAD,EAAA,CACA,GAAAE,GAAAR,EAAA9C,UAAAoD,EACAD,GAAA,SAAA7D,GACA,GAAArC,GAAAqG,EAAAvO,KAAA2D,KAAA4G,EACA+C,GAAApF,IACAmE,EAAAe,KAAAxB,OAAA1D,SAIAkG,GAAA5N,EAAAyM,EAGA,IAAA5M,GAAA,SAAAkK,GAEA,GAAAsD,MAAA7N,KAAA2D,KAAA4G,GACA,QAGA,IAAAiE,GAAAC,EAAAzO,KAAA2D,KAAAgK,EAAApD,EACAkD,GACApB,EAAAqC,YAAAlG,EAAA,GAAAgG,IAEAnC,EAAAsC,YAAAnG,EAAA,GAAAgG,GACAJ,EAAApO,KAAA2D,KAAA4G,GACA8B,EAAAuC,aAAApG,KAIAqG,EAAA5B,EAAAxL,aAAAqN,GACAC,EAAA9B,EAAAxL,aAAAuN,GACAC,EAAAhC,EAAAxL,aAAAyN,GAEA9D,EAAA6B,EAAAxL,aAAA0N,EAYA,OAVAN,GACAxO,EAAA+O,EAAAP,EAAAxO,EAAA+K,GACG2D,EACHX,EAAAgB,EAAAL,EAAAX,EAAAhD,GACG6D,EACH5O,EAAAgP,EAAAJ,EAAA5O,EAAA+K,GACGA,IACH/K,EAAAiP,EAAAlE,EAAA/K,IAGAA,EAGA,QAAA+O,GAAArE,EAAA1K,EAAA+K,GACA,GAAAd,GAAAyD,EAAA9C,UAAAF,EACA,iBAAAR,GACA,GAAAgF,GAAAjF,EAAAtK,KAAA2D,KAAA4G,EACAyC,GAAAhN,KAAA2D,KAAA4L,EAAAlP,EAAA+K,IAIA,QAAAiE,GAAAtE,EAAA1K,EAAA+K,GACA,GAAAd,GAAAyD,EAAA9C,UAAAF,EAEA,OADAK,KAAA/K,EAAAiP,EAAAlE,EAAA/K,IACA,SAAAkK,GACAA,EAAAD,EAAAtK,KAAA2D,KAAA4G,GACAlK,EAAAL,KAAA2D,KAAA4G,IAIA,QAAAqD,GAAAX,GAGA,OAFAuC,MACAhB,EAAAvB,EAAA1F,WACAjF,EAAA,EAAiBA,EAAAkM,EAAAzN,OAAkBuB,IAAA,CACnC,GAAA8H,GAAAoE,EAAAlM,GACAkG,EAAAoD,OAAAxB,EAAA5B,KACA,QAAAA,EAAAvG,QAAAwN,GAAA,CAEA,GADAjH,IAAAkH,OAAAD,EAAA1O,QACA4O,EAAA1N,QAAAuG,GAAA,GACA,KAEA,IAAAoH,GAAA7B,EAAA9C,UAAAb,EAAAlC,MACA,QAAAM,GACA,YACAoH,EAAAC,EAAApH,UAAAmH,EACA,MACA,aACAA,EAAAC,EAAAC,MAAAF,GAGAJ,EAAAhH,GAAAoH,MAEAJ,GAAAhH,GAAA4B,EAAAlC,MAGA,MAAAsH,GAGA,QAAAf,GAAAd,EAAApD,GACA,GAAAiE,KACA,QAAAuB,KAAApC,GAAA,CACA,GAAAzF,GAAAyF,EAAAoC,EACA,mBAAA7H,KACAA,IAAAlI,KAAA2D,KAAA4G,EAAAwF,IAEAzC,EAAApF,IACAsG,EAAAxL,KAAA+M,EAAA7H,GAGA,MAAAsG,GAGA,QAAAN,GAAAjB,EAAAd,GACA,MAAAc,IAAA+C,kBACA/C,GAGA,GAAAA,EAAAgD,QAAA9D,GAAA,MAAAc,EAEA,UAAA3D,OAAA,uCAAA6C,GAGA,QAAAuB,GAAAlF,GACA,MAAA0H,GAAAjO,QAAAuG,GAAA,GAGA,QAAAwE,GAAAzC,EAAAS,EAAAI,GACA,GACA+E,GAAA/E,EACAkE,EAAAlE,EAAAJ,GACAA,CAEA,oBAAAT,GAAA,CACA,GAAA6F,MAAAC,QAAA9F,GACA,MAAAA,GAAAyC,QAAAmD,EAAAxM,KAGA,IAAArB,GAAA,CACA,QAAAyN,KAAAxF,GACAA,EAAA/E,eAAAuK,IACAI,EAAAnQ,KAAA2D,MAA4BoM,MAAA7H,MAAAqC,EAAAwF,IAA2BzN,SAGpD,oBAAAiI,GACH,MAAAA,GAAA+F,MAAA,IAAAtD,QAAAmD,EAAAxM,MAMA,QAAA2L,GAAAlE,EAAAJ,GACA,gBAAAT,GACA,GAAAF,GAAAQ,EAAAlH,KAAAyH,EAAAb,EACAS,GAAAhL,KAAA2D,KAAA4G,GACAM,EAAAlH,KAAAyH,EAAAf,IAIA,QAAAiD,GAAApF,GACA,cAAAA,GAAAqI,SAAArI,EAGA,QAAAiG,GAAAnD,GACA,kBACA,OAAAA,EAAA9B,MAAAvF,KAAAwF,YAIA,QAAA0B,GAAAqB,EAAAd,EAAAlD,GACA,GAAAmC,GAAA6B,EAAAd,EAMA,OALAmF,UAAArI,QACAgE,GAAAd,GAEAc,EAAAd,GAAAlD,EAEAmC,EAGA,QAAAmD,MAjSA,GACAnB,IADA5M,EAAA,GACAA,EAAA,IACAsO,EAAAtO,EAAA,GACA4N,EAAA5N,EAAA,IACAoQ,EAAApQ,EAAA,GAGAgQ,EAAA,KAEAN,EAAAM,EAAA,KACAlC,EAAAkC,EAAA,OACA3B,EAAA2B,EAAA,KACAzB,EAAAyB,EAAA,OACAX,EAAAW,EAAA,OACAT,EAAAS,EAAA,UACAP,EAAAO,EAAA,OACAnB,EAAAmB,EAAA,OAEAE,GACA,KACA,OACA,OACA,UACA,OACA,OACA,KACA,QAGAO,GACA,sDACA,wDACA,MAGArQ,GAAAD,SACAa,OAAAuL,EACA3L,OAAA,SAAA4L,EAAA1B,EAAA2B,GACA,GAAA7L,GAAA2L,EAAAC,EAAAC,EAEA,OADA7L,GAAAkK,GACAlK,KRoeM,SAASR,EAAQD,EAASH,IAEH,SAAS+Q;;;;;;;;;;;;;;;;AS5ftC,YA2DA,SAAAC,GAAAxD,GAOAtJ,KAAA+M,UAKA/M,KAAAsI,KAAAgB,EAKAtJ,KAAAgN,YAAA1D,EAuCA,QAAA2D,GAAA3D,EAAA4D,GAIAlN,KAAAmN,OAAA,GAAAL,GAAAxD,GAKAtJ,KAAAoN,IAAA9D,EAAA+D,cAOArN,KAAAsN,UAAAV,QAKA5M,KAAAkN,cAKAlN,KAAAa,QAAA5E,EAAAsR,cAAAC,iBAKAxN,KAAAyN,QAAAxR,EAAAsR,cAAAG,iBAsIA,QAAAC,GAAA5P,EAAAqO,GAKApM,KAAA6K,MAAA+C,IAQA5N,KAAA6N,YAMA7N,KAAA8N,SAAAF,IAOA5N,KAAAoM,MAMApM,KAAA+N,OAAA,KAMA/N,KAAAgO,aAAA,EAMAhO,KAAAiO,iBAAA,KAMAjO,KAAAjC,WAKAiC,KAAAyJ,KAAA,KA5TAxN,EAAAsR,eAMAC,aAAA,KAQAE,aAAA,MAiDAZ,EAAAnL,UAAAuM,iBAAA,WACA,MAAAlO,MAAA+M,OAAA/M,KAAA+M,OAAA3P,OAAA,IAMA0P,EAAAnL,UAAAoH,WAAA,WACA/I,KAAA+M,OAAA1N,KAAAW,KAAAgN,aACAhN,KAAAgN,YAAAhN,KAAAgN,YAAAjE,YAMA+D,EAAAnL,UAAAqH,YAAA,WACAhJ,KAAAgN,YAAAhN,KAAAgN,YAAAhE,aAMA8D,EAAAnL,UAAAwM,WAAA,WACAnO,KAAAgN,YAAAhN,KAAA+M,OAAAqB,OA+CAnB,EAAAtL,UAAA0M,oBAAA,WACA,MAAArO,MAAAsN,SAAAtN,KAAAsN,SAAAlQ,OAAA,IAMA6P,EAAAtL,UAAA2M,eAAA,SAAAC,GACAvO,KAAAsN,SAAAjO,KAAAkP,IAMAtB,EAAAtL,UAAA6M,cAAA,WACAxO,KAAAsN,SAAAc,OAMAnB,EAAAtL,UAAA8M,YAAA,SAAAnF,GACAtJ,KAAAa,SACAb,KAAAa,QAAAxB,KAAAiK,IAOA2D,EAAAtL,UAAA+M,YAAA,SAAApF,GACAtJ,KAAAyN,SACAzN,KAAAyN,QAAApO,KAAAiK,IAOA2D,EAAAtL,UAAAgN,cAAA,WACA3O,KAAAa,SAAAb,KAAAa,QAAAzD,OAAA,GACAnB,EAAAsR,cAAAC,aAAAxN,KAAAa,SAGAb,KAAAyN,SAAAzN,KAAAyN,QAAArQ,OAAA,GACAnB,EAAAsR,cAAAG,aAAA1N,KAAAyN,SAQA,IAAAlF,GAMAqG,EAAA,SAAAtF,GACAf,EAAA,GAAA0E,GAAA3D,EAAAf,IAMAsG,EAAA,WACAtG,IAAA2E,aAOA4B,EAAA,WACA,MAAAvG,IAsBA1G,EAAAkE,OAAApE,UAAAE,eAKA/E,EAAAiJ,OAAAjJ,OAQAiS,EAAA,SAAAlD,EAAA7F,GACA,MAAAnE,GAAAxF,KAAAwP,EAAA7F,IAOA4H,EAAA,WACA,MAAA9Q,GAAA,OA2EAkS,EAAA,SAAA1F,EAAAvL,EAAAqO,GACA,GAAAxF,GAAA,GAAA+G,GAAA5P,EAAAqO,EAEA,OADA9C,GAAA,qBAAA1C,EACAA,GASAqI,EAAA,SAAA3F,GACA,GAAA1C,GAAA0C,EAAA,oBAEA,KAAA1C,EAAA,CACA,GAAA7I,GAAAuL,EAAAvL,SAAA0H,cACA2G,EAAA,IAEA9C,aAAAnG,WACAiJ,EAAA9C,EAAAxL,aAAA,QAGA8I,EAAAoI,EAAA1F,EAAAvL,EAAAqO,GAGA,MAAAxF,GAmBA3K,GAAAiT,SACAC,UAAA,YAEAC,YAAA,iBAWAnT,EAAAoT,UAAA,SAAAC,EAAAzK,EAAAN,GACA,MAAAA,EACA+K,EAAA7L,gBAAAoB,GAEAyK,EAAA7O,aAAAoE,EAAAN,IAUAtI,EAAAsT,UAAA,SAAAD,EAAAzK,EAAAN,GACA+K,EAAAzK,GAAAN,EAWA,IAAAiL,GAAA,SAAAF,EAAAzK,EAAAsH,GACA,mBAAAA,GACAmD,EAAAnD,MAAAsD,QAAAtD,MACG,CACHmD,EAAAnD,MAAAsD,QAAA,EACA,IAAAC,GAAAJ,EAAAnD,KAEA,QAAAwD,KAAAxD,GACA4C,EAAA5C,EAAAwD,KACAD,EAAAC,GAAAxD,EAAAwD,MAcAC,EAAA,SAAAN,EAAAzK,EAAAN,GACA,GAAAQ,SAAAR,EAEA,YAAAQ,GAAA,aAAAA,EACA9I,EAAAsT,UAAAD,EAAAzK,EAAAN,GAEAtI,EAAAoT,UAAAC,EAAAzK,EAAoEN,IAUpEsL,EAAA,SAAAP,EAAAzK,EAAAN,GACA,GAAAqC,GAAAqI,EAAAK,GACAzE,EAAAjE,EAAAiE,KAEA,IAAAA,EAAAhG,KAAAN,EAAA,CAIA,GAAAuL,GAAA7T,EAAA2H,WAAAiB,IAAA5I,EAAA2H,WAAA3H,EAAAiT,QAAAjT,WACA6T,GAAAR,EAAAzK,EAAAN,GAEAsG,EAAAhG,GAAAN,GAOAtI,GAAA2H,WAAAgK,IAIA3R,EAAA2H,WAAA3H,EAAAiT,QAAAjT,YAAA2T,EAEA3T,EAAA2H,WAAA3H,EAAAiT,QAAAE,aAAA,aAEAnT,EAAA2H,WAAA,MAAA4L,CAEA,IAAAO,GAAA,6BAOAC,EAAA,SAAAC,GACA,QAAAA,EACAnB,IAAAR,eAAAyB,GACG,kBAAAE,GACHnB,IAAAR,eAAA1B,SASAsD,EAAA,SAAAD,IACA,QAAAA,GAAA,kBAAAA,IACAnB,IAAAN,iBASA2B,EAAA,SAAAF,GACA,cAAAA,EACAF,EAGAjB,IAAAT,uBAYA1K,EAAA,SAAAyJ,EAAA6C,EAAA7D,EAAAgE,GACA,GACAd,GADAf,EAAA4B,EAAAF,EAWA,IAPAX,EADAf,EACAnB,EAAAiD,gBAAA9B,EAAA0B,GAEA7C,EAAAzJ,cAAAsM,GAGAjB,EAAAM,EAAAW,EAAA7D,GAEAgE,EACA,OAAAzR,GAAA,EAAmBA,EAAAyR,EAAAhT,OAAoBuB,GAAA,EACvCkR,EAAAP,EAA6Cc,EAAAzR,GAAAyR,EAAAzR,EAAA,GAI7C,OAAA2Q,IAeAgB,EAAA,SAAAlD,EAAArP,EAAAqO,EAAAgE,GACA,gBAAArS,EACAqP,EAAAmD,eAAA,IAGA5M,EAAAyJ,EAAArP,EAAAqO,EAAAgE,IASAI,EAAA,SAAAlB,GAKA,OAJAzD,GAAA+B,IACA6C,EAAAnB,EAAAmB,SACAC,EAAAD,EAAArT,OAEAuB,EAAA,EAAiB+R,EAAA/R,EAAWA,GAAA,GAC5B,GAAAmK,GAAA2H,EAAA9R,GACAyN,EAAA6C,EAAAnG,GAAAsD,GAEAA,KACAP,EAAAO,GAAAtD,GAIA,MAAA+C,IASA8E,EAAA,SAAArB,GACA,GAAA1I,GAAAqI,EAAAK,EAMA,OAJA1I,GAAAmH,SACAnH,EAAAmH,OAAAyC,EAAAlB,IAGA1I,EAAAmH,QASA6C,EAAA,SAAAC,EAAAzE,GACA,MAA8BA,IAAAuE,EAAAE,GAAAzE,IAY9B0E,EAAA,SAAAD,EAAAzE,EAAAtD,GACA6H,EAAAE,GAAAzE,GAAAtD,EAGA,mBAAA+D,EAAAkE,IAAAC,SAOA,GAAAC,GAAA,SAAA3H,EAAA2G,EAAA7D,GACA,GAAArO,GAAAkR,EAAA3F,GAAAvL,QACA,IAAAA,IAAAkS,EACA,SAAAtK,OAAA,gCAAAyG,EAAA,aAAA6D,EAAA,WAAAlS,EAAA,KAaA,IAAAuO,GAAA,SAAAhD,EAAAvL,EAAAqO,GACA,GAAAxF,GAAAqI,EAAA3F,EAKA,OAAA8C,IAAAxF,EAAAwF,KAAArO,IAAA6I,EAAA7I,UAaAmT,EAAA,SAAAnT,EAAAqO,EAAAgE,GACA,GAIAe,GAJA5I,EAAAuG,IACA3B,EAAA5E,EAAA4E,OACAH,EAAAG,EAAAH,YACA6D,EAAA1D,EAAAe,kBAIA,IAAAlB,GAAAV,EAAAU,EAAAjP,EAAAqO,GACA+E,EAAAnE,MACG,CACH,GAAAoE,GAAAR,EAAAC,EAAAzE,EAIAgF,IACA,eAAAvE,EAAAkE,IAAAC,UACAC,EAAAG,EAAArT,EAAAqO,GAGA+E,EAAAC,IAEAD,EAAAb,EAAA/H,EAAA6E,IAAArP,EAAAqO,EAAAgE,GAEAhE,GACA0E,EAAAD,EAAAzE,EAAA+E,GAGA5I,EAAAkG,YAAA0C,IAOAnE,GAAAiC,EAAAjC,GAAAZ,KACAyE,EAAAQ,aAAAF,EAAAnE,GACAiC,EAAA4B,GAAA7C,aAAA,GAEA6C,EAAAS,aAAAH,EAAAnE,GAGAG,EAAAH,YAAAmE,EAGA,MAAAA,IAQAI,EAAA,SAAAjI,GACA,GAOA8C,GAPA7D,EAAAuG,IACA3B,EAAA5E,EAAA4E,OACAvG,EAAAqI,EAAA3F,GACAyE,EAAAnH,EAAAmH,OACAC,EAAApH,EAAAoH,YACAC,EAAArH,EAAAqH,iBACAnF,EAAAQ,EAAAkI,SAKA,IAFA5K,EAAAqH,iBAAA,OAEAnF,IAAAmF,GAAAD,GAIApH,EAAAiE,MAAA5O,EAAAiT,QAAAE,cAAAjC,EAAAH,cAAAG,EAAA7E,MAAA,CAIA,KAAAQ,IAAAmF,GACA3E,EAAAmI,YAAA3I,GACAP,EAAAmG,YAA0C5F,GAE1CsD,EAAA6C,EAAAnG,GAAAsD,IACAA,SACA2B,GAAA3B,GAEAtD,EAAAQ,EAAAkI,SAIA,KAAApF,IAAA2B,GACAjF,EAAAiF,EAAA3B,GACAtD,EAAAqF,aACA5F,EAAAmG,YAAA5F,SACAiF,GAAA3B,GAIAxF,GAAAoH,aAAA,IAOA0D,EAAA,SAAApI,GACA,GAAA1C,GAAAqI,EAAA3F,EACA0G,GAAApJ,EAAA7I,WAOA4T,EAAA,SAAArI,GACA,GAAA1C,GAAAqI,EAAA3F,EACA4G,GAAAtJ,EAAA7I,WAOA6T,EAAA,SAAAtI,GACA,GAAAf,GAAAuG,IACA3B,EAAA5E,EAAA4E,OACA0D,EAAA1D,EAAAe,mBACAtH,EAAAqI,EAAA4B,EACAjK,GAAAqH,iBAAA3E,GAMAP,EAAA,WACA,GAAAR,GAAAuG,IACA3B,EAAA5E,EAAA4E,MACAuE,GAAAvE,EAAAH,aACAG,EAAApE,cAMAC,EAAA,WACA,GAAAT,GAAAuG,IACA3B,EAAA5E,EAAA4E,MACAyE,GAAAzE,EAAAH,aACAG,EAAAnE,eAMAmF,EAAA,WACA,GAAA5F,GAAAuG,IACA3B,EAAA5E,EAAA4E,MACAA,GAAAgB,aACAwD,EAAAxE,EAAAH,aAGA,mBAAAH,EAAAkE,IAAAC,SACA,GAAAa,GAAA,SAAAvJ,GACA,GAAAwJ,GAAAhD,IAAA3B,OAAAe,kBACA,IAAA4D,EAAA,CAKA,IADA,GAAAC,MACAD,OAAAxJ,GACAyJ,EAAA1S,KAAAyS,EAAA/T,SAAA0H,eACAqM,IAAA3D,UAGA,UAAAxI,OAAA,sCAAAoM,EAAAjK,KAAA,QAcA7L,GAAA0M,MAAA,SAAAW,EAAAjC,EAAAT,GACAgI,EAAAtF,GAEAP,IACA1B,EAAAT,GACAuH,IACAoD,EAAAjI,GAEA,eAAAuD,EAAAkE,IAAAC,UACAa,EAAAvI,GAGAwF,IAAAH,gBACAE,IAQA,IAAAmD,GAAA,EAOAC,IAEA,mBAAApF,EAAAkE,IAAAC,SAMA,GAAAkB,IAAA,EAGAC,EAAA,WACA,GAAAD,EACA,SAAAvM,OAAA,qGAKAyM,EAAA,WACA,IAAAF,EACA,SAAAvM,OAAA,sJAUA0M,EAAA,SAAAjG,GACA,IAAAA,EACA,SAAAzG,OAAA,oDAQA2M,EAAA,SAAArC,GACA,GAAA1H,GAAAuG,IACA3B,EAAA5E,EAAA4E,OACAoF,EAAApF,EAAAe,mBACAtH,EAAAqI,EAAAsD,EAEA,IAAAtC,IAAArJ,EAAA7I,SACA,SAAA4H,OAAA,4BAAAsK,EAAA,QAAArJ,EAAA7I,SAAA,eAKAyU,EAAA,WACAN,GAAA,GAIAO,EAAA,WACAP,GAAA,EAgBAjW,GAAA+O,YAAA,SAAAiF,EAAA7D,EAAAgE,EAAAsC,GACA,eAAA7F,EAAAkE,IAAAC,UACAmB,GAiBA,KAdA,GAAA7I,GAAiC4H,EAAAjB,EAAA7D,EAAAgE,GACjCxJ,EAAAqI,EAAA3F,GAQAuE,EAAAjH,EAAAiH,SACA8E,GAAA,EACAhU,EAAAqT,EACArU,EAAA,EAEQgB,EAAA6G,UAAApI,OAAsBuB,GAAA,EAAAhB,GAAA,EAC9B,GAAAkQ,EAAAlQ,KAAA6H,UAAA7G,GAAA,CACAgU,GAAA,CACA,OAIA,KAAQhU,EAAA6G,UAAApI,OAAsBuB,GAAA,EAAAhB,GAAA,EAC9BkQ,EAAAlQ,GAAA6H,UAAA7G,EAWA,IARAhB,EAAAkQ,EAAAzQ,SACAuV,GAAA,EACA9E,EAAAzQ,OAAAO,GAMAgV,EAAA,CACA,GAAAlM,GACAqH,EAAAlH,EAAAkH,QAEA,KAAArH,IAAAqH,GACAA,EAAArH,GAAAmG,MAGA,KAAAjO,EAAAqT,EAA+BrT,EAAA6G,UAAApI,OAAsBuB,GAAA,EACrDmP,EAAAtI,UAAA7G,IAAA6G,UAAA7G,EAAA,EAGA,KAAA8H,IAAAqH,GACA+B,EAAAvG,EAAA7C,EAAAqH,EAAArH,IAKA,MADAsC,KACAO,GAiBArN,EAAA2W,iBAAA,SAAA3C,EAAA7D,EAAAgE,GACA,eAAAvD,EAAAkE,IAAAC,WACAmB,IACAK,KAGAP,EAAA,GAAAhC,EACAgC,EAAA,GAAA7F,EACA6F,EAAA,GAAA7B,GAUAnU,EAAAwK,KAAA,SAAA5B,EAAAN,GACA,eAAAsI,EAAAkE,IAAAC,UACAoB,IAGAH,EAAA5S,KAAAwF,EAAAN,IAOAtI,EAAA4W,eAAA,WACA,eAAAhG,EAAAkE,IAAAC,WACAoB,IACAK,IAGA,IAAAnJ,GAAArN,EAAA+O,YAAAzF,MAAA,KAAA0M,EAEA,OADAA,GAAA7U,OAAA,EACAkM,GASArN,EAAAgP,aAAA,SAAAgF,GACA,eAAApD,EAAAkE,IAAAC,WACAmB,IACAG,EAAArC,IAGA9B,GAEA,IAAA7E,GAAiCwF,IAAA3B,OAAAH,WAKjC,OAHAuE,GAAAjI,GAEAN,IACAM,GAiBArN,EAAA8O,YAAA,SAAAkF,EAAA7D,EAAAgE,EAAAsC,GACA,GAAApJ,GAAArN,EAAA+O,YAAAzF,MAAA,KAAAC,UAEA,OADAvJ,GAAAgP,aAAA1F,MAAA,KAAAC,WACA8D,GAoBArN,EAAA6W,mBAAA,SAAA7C,EAAA7D,EAAAgE,EAAAsC,GACA,eAAA7F,EAAAkE,IAAAC,UACAqB,EAAAjG,EAGA,IAAA9C,GAAArN,EAAA+O,YAAAzF,MAAA,KAAAC,UAGA,OAFAqK,GAAAvG,EAAArN,EAAAiT,QAAAE,aAAA,GACAnT,EAAAgP,aAAA1F,MAAA,KAAAC,WACA8D,GAYArN,EAAAwN,KAAA,SAAAlF,EAAAmO,GACA,eAAA7F,EAAAkE,IAAAC,UACAmB,GAGA,IAAA7I,GAA8B4H,EAAA,cAC9BtK,EAAAqI,EAAA3F,EAEA,IAAA1C,EAAA6C,OAAAlF,EAAA,CACAqC,EAAA6C,KAAkClF,CAGlC,QADAwO,GAAAxO,EACA5F,EAAA,EAAmBA,EAAA6G,UAAApI,OAAsBuB,GAAA,EACzCoU,EAAAvN,UAAA7G,GAAAoU,EAGAzJ,GAAA1C,KAAAmM,EAIA,MADA/J,KACAM,KTihB8BjN,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,GUpsDvB,QAAA+W,KACAC,GAAA,EACAC,EAAA9V,OACA+V,EAAAD,EAAArN,OAAAsN,GAEAC,EAAA,GAEAD,EAAA/V,QACAiW,IAIA,QAAAA,KACA,IAAAJ,EAAA,CAGA,GAAAK,GAAAjP,WAAA2O,EACAC,IAAA,CAGA,KADA,GAAAM,GAAAJ,EAAA/V,OACAmW,GAAA,CAGA,IAFAL,EAAAC,EACAA,OACAC,EAAAG,GACAL,GACAA,EAAAE,GAAAI,KAGAJ,GAAA,GACAG,EAAAJ,EAAA/V,OAEA8V,EAAA,KACAD,GAAA,EACAQ,aAAAH,IAiBA,QAAAI,GAAAC,EAAAC,GACA5T,KAAA2T,MACA3T,KAAA4T,QAYA,QAAA/J,MAtEA,GAGAqJ,GAHArG,EAAA3Q,EAAAD,WACAkX,KACAF,GAAA,EAEAG,EAAA,EAsCAvG,GAAAgH,SAAA,SAAAF,GACA,GAAAzL,GAAA,GAAAuE,OAAAjH,UAAApI,OAAA,EACA,IAAAoI,UAAApI,OAAA,EACA,OAAAuB,GAAA,EAAuBA,EAAA6G,UAAApI,OAAsBuB,IAC7CuJ,EAAAvJ,EAAA,GAAA6G,UAAA7G,EAGAwU,GAAA9T,KAAA,GAAAqU,GAAAC,EAAAzL,IACA,IAAAiL,EAAA/V,QAAA6V,GACA5O,WAAAgP,EAAA,IASAK,EAAA/R,UAAA6R,IAAA,WACAxT,KAAA2T,IAAApO,MAAA,KAAAvF,KAAA4T,QAEA/G,EAAAiH,MAAA,UACAjH,EAAAkH,SAAA,EACAlH,EAAAkE,OACAlE,EAAAmH,QACAnH,EAAAoH,QAAA,GACApH,EAAAqH,YAIArH,EAAAsH,GAAAtK,EACAgD,EAAAuH,YAAAvK,EACAgD,EAAAwH,KAAAxK,EACAgD,EAAAyH,IAAAzK,EACAgD,EAAA0H,eAAA1K,EACAgD,EAAA2H,mBAAA3K,EACAgD,EAAA4H,KAAA5K,EAEAgD,EAAA6H,QAAA,SAAA7P,GACA,SAAAc,OAAA,qCAGAkH,EAAA8H,IAAA,WAA2B,WAC3B9H,EAAA+H,MAAA,SAAAC,GACA,SAAAlP,OAAA,mCAEAkH,EAAAiI,MAAA,WAA4B,WVmtDtB,SAAS5Y,EAAQD,GWpxDvB,QAAA8Y,GAAAC,GACA,MAAAvI,OAAAC,QAAAsI,GACAA,EAAAlN,KAAA,MAEA/B,OAAAkP,KAAAD,GACAnJ,IAAA,SAAAO,GACA,OACA8I,EAAA9I,GACA,KACA4I,EAAA5I,GACA,KACAtE,KAAA,MAEAA,KAAA,KAGA,QAAAoN,GAAAC,GACA,MAAAA,GAAAC,QAAA,kBAAAC,GACA,UAAAA,EAAA5P,gBAIA,QAAA6P,GAAAN,GACA,MAAAvI,OAAAC,QAAAsI,GACAA,EAAAlN,KAAA,KAEA/B,OAAAkP,KAAAD,GAAAO,OAAA,SAAAnJ,GACA,QAAA4I,EAAA5I,KACGtE,KAAA,KArDH,GAAAqE,GAAA,SAAAF,GACA,kBACA,GAAArF,GAAAqF,EAAA1G,MAAAvF,KAAAwF,UACA,OAAAoB,IAAA,gBAAAA,GACAmO,EAAAnO,GAEAA,IAIA9B,EAAA,SAAAmH,GACA,kBACA,GAAArF,GAAAqF,EAAA1G,MAAAvF,KAAAwF,UACA,OAAAoB,IAAA,gBAAAA,GACA0O,EAAA1O,GAEAA,GAIA1K,GAAAD,SACAkQ,QACArH,cXo1DM,SAAS5I,EAAQD,EAASH,GYt2DhC,QAAA4N,GAAAH,EAAA3C,GACA,GAAA4O,GAAAxV,IACA,OAAAuJ,GAAA6L,QAAA,eAAsC,SAAAxS,EAAA+D,GACtC,MAAAV,GAAA5J,KAAAmZ,EAAA7O,EAAAC,KAPA,GAAAX,GAAAnK,EAAA,GAAAmK,QAEA/J,GAAAD,QAAAyN","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t\n\tvar Template = __webpack_require__(2);\n\tvar render = __webpack_require__(6);\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: render.create,\n\t  render: render.render\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*! (C) WebReflection Mit Style License */\n\t(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(3);\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar createRenderer = __webpack_require__(6).create;\n\t\n\tvar RENDER = '__render';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        console.log('attached!', this);\n\t        this.update();\n\t      }},\n\t\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      render: {value: function(data) {\n\t        if (!arguments.length) data = this.data;\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t        this.render();\n\t      }},\n\t\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, value) {\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      return read ? read.call(this, value) : value;\n\t    },\n\t\n\t    set: function(v) {\n\t      if (v !== value) {\n\t        var previous = value;\n\t        return value = write.call(this, v, previous);\n\t      }\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrow = __webpack_require__(5);\n\t\n\tvar evaluate = function(expression, data) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, data);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (arrow.is(expression)) {\n\t    return parseArrow(expression);\n\t  }\n\t\n\t  var symbol = 'd' + Date.now();\n\t  // '.' is just the identity function\n\t  if (expression === '.') {\n\t    return function identity(d) { return d; };\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    '  with (this) {',\n\t    '    with (', symbol, ') {',\n\t    '      return ', expression, ';',\n\t    '    } ',\n\t    '  } ',\n\t    '} catch (error) { }'\n\t  ].join(''));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator,\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = match[4] || match[5];\n\t  return new Function(args, 'return (' + body + ')');\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar incremental = __webpack_require__(7);\n\tvar xp = __webpack_require__(4);\n\tvar interpolate = __webpack_require__(10);\n\tvar transform = __webpack_require__(9);\n\t\n\t// our attribute namespace\n\tvar T_NS = 't-';\n\t\n\tvar T_AS = T_NS + 'as';\n\tvar T_SKIP = T_NS + 'skip';\n\tvar T_IF = T_NS + 'if';\n\tvar T_ELSE = T_NS + 'else';\n\tvar T_EACH = T_NS + 'each';\n\tvar T_FOREACH = T_NS + 'foreach';\n\tvar T_WITH = T_NS + 'with';\n\tvar T_TEXT = T_NS + 'text';\n\t\n\tvar CONTROL_ATTRS = [\n\t  'if',\n\t  'else',\n\t  'each',\n\t  'foreach',\n\t  'with',\n\t  'text',\n\t  'as',\n\t  'skip'\n\t];\n\t\n\tvar VOID_ELEMENTS = [\n\t  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n\t  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n\t  'wbr'\n\t];\n\t\n\tmodule.exports = {\n\t  create: createRenderFunction,\n\t  render: function(root, data, context) {\n\t    var render = createRenderFunction(root, context);\n\t    render(data);\n\t    return render;\n\t  }\n\t};\n\t\n\tfunction createRenderFunction(root, context) {\n\t  if (typeof root === 'string') {\n\t    var selector = root;\n\t    root = document.querySelector(selector);\n\t    if (!root) {\n\t      throw new Error('no element found with selector: \"' + selector + '\"');\n\t    }\n\t  }\n\t  var render = createRenderer(root);\n\t  if (arguments.length < 2) context = {};\n\t  return function _render(data) {\n\t    // console.log('rendering with data:', data);\n\t    return incremental.patch(root, render.bind(context, data));\n\t  };\n\t}\n\t\n\tfunction createRenderer(root) {\n\t  var calls = [];\n\t  for (\n\t    var child = root.firstChild; child;\n\t    child = child.nextSibling\n\t  ) {\n\t    switch (child.nodeType) {\n\t      case Node.TEXT_NODE:\n\t        calls.push(createTextRenderer(child));\n\t        break;\n\t      case Node.ELEMENT_NODE:\n\t        calls.push(createElementRenderer(child));\n\t        break;\n\t    }\n\t  }\n\t  return function patch(data) {\n\t    // console.log('patching:', root, 'with', data);\n\t    calls.forEach(function(fn) {\n\t      fn.call(this, data);\n\t    }, this);\n\t  };\n\t}\n\t\n\tfunction createTextRenderer(node) {\n\t  var template = node.nodeValue;\n\t  return function(data) {\n\t    var text = interpolate.call(this, template, data);\n\t    incremental.text(defined(text) ? text : '');\n\t  };\n\t}\n\t\n\tfunction createElementRenderer(node) {\n\t  var name = node.nodeName.toLowerCase();\n\t\n\t  // this element will never be rendered if it has a truthy t-skip attribute\n\t  if (node.hasAttribute(T_SKIP)) {\n\t    return noop;\n\t  }\n\t\n\t  var isVoid = isElementVoid(name);\n\t  var attrMap = getAttributeMap(node);\n\t\n\t  var condition = node.hasAttribute(T_IF)\n\t    ? xp.evaluator(node.getAttribute(T_IF))\n\t    : null;\n\t\n\t  if (node.hasAttribute(T_ELSE)) {\n\t    if (condition) throw new Error('element has both t-if and t-else attributes');\n\t    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n\t    if (!ifSibling) throw new Error('element with t-else has no matching t-if sibling');\n\t    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n\t  }\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  var textExpression = node.getAttribute(T_TEXT);\n\t  if (textExpression) {\n\t    var getText = xp.evaluator(textExpression);\n\t    renderChildren = function(data) {\n\t      var value = getText.call(this, data);\n\t      if (defined(value)) {\n\t        incremental.text(String(value));\n\t      }\n\t    };\n\t  } else {\n\t    renderChildren = createRenderer(node);\n\t  }\n\t\n\t  var render = function(data) {\n\t    // console.log('rendering', node, 'with data:', data);\n\t    if (condition && !condition.call(this, data)) {\n\t      return false;\n\t    }\n\t\n\t    var attrs = interpolateAttributes.call(this, attrMap, data);\n\t    if (isVoid) {\n\t      incremental.elementVoid(name, '', attrs);\n\t    } else {\n\t      incremental.elementOpen(name, '', attrs);\n\t      renderChildren.call(this, data);\n\t      incremental.elementClose(name);\n\t    }\n\t  };\n\t\n\t  var eachExpression = node.getAttribute(T_EACH);\n\t  var forEachExpression = node.getAttribute(T_FOREACH);\n\t  var withExpression = node.getAttribute(T_WITH);\n\t\n\t  var symbol = node.getAttribute(T_AS);\n\t\n\t  if (eachExpression) {\n\t    render = renderEach(eachExpression, render, symbol);\n\t  } else if (forEachExpression) {\n\t    renderChildren = renderEach(forEachExpression, renderChildren, symbol);\n\t  } else if (withExpression) {\n\t    render = renderWith(withExpression, render, symbol);\n\t  } else if (symbol) {\n\t    render = symbolSetter(symbol, render);\n\t  }\n\t\n\t  return render;\n\t}\n\t\n\tfunction renderEach(expression, render, symbol) {\n\t  var expr = xp.evaluator(expression);\n\t  return function(data) {\n\t    var values = expr.call(this, data);\n\t    forEach.call(this, values, render, symbol);\n\t  };\n\t}\n\t\n\tfunction renderWith(expression, render, symbol) {\n\t  var expr = xp.evaluator(expression);\n\t  if (symbol) render = symbolSetter(symbol, render);\n\t  return function(data) {\n\t    data = expr.call(this, data);\n\t    render.call(this, data);\n\t  };\n\t}\n\t\n\tfunction getAttributeMap(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = String(attr.name);\n\t    if (name.indexOf(T_NS) === 0) {\n\t      name = name.substr(T_NS.length);\n\t      if (CONTROL_ATTRS.indexOf(name) > -1) {\n\t        break;\n\t      }\n\t      var getter = xp.evaluator(attr.value);\n\t      switch (name) {\n\t        case 'class':\n\t          getter = transform.className(getter);\n\t          break;\n\t        case 'style':\n\t          getter = transform.style(getter);\n\t          break;\n\t      }\n\t      map[name] = getter;\n\t    } else {\n\t      map[name] = attr.value;\n\t    }\n\t  }\n\t  return map;\n\t}\n\t\n\tfunction interpolateAttributes(attrMap, data) {\n\t  var attrs = [];\n\t  for (var key in attrMap) {\n\t    var value = attrMap[key];\n\t    if (typeof value === 'function') {\n\t      value = value.call(this, data, key);\n\t    }\n\t    if (defined(value)) {\n\t      attrs.push(key, value);\n\t    }\n\t  }\n\t  return attrs;\n\t}\n\t\n\tfunction getPreviousSibling(node, selector) {\n\t  while (node = node.previousSibling) {\n\t    if (!node) break;\n\t    // FIXME this needs a vendor prefix in IE 9+\n\t    // <http://caniuse.com/#search=matches>\n\t    if (node.matches(selector)) return node;\n\t  }\n\t  throw new Error('no previous sibling found matching: ' + selector);\n\t}\n\t\n\tfunction isElementVoid(name) {\n\t  return VOID_ELEMENTS.indexOf(name) > -1;\n\t}\n\t\n\tfunction forEach(data, fn, symbol) {\n\t  var previous;\n\t  var iterate = symbol\n\t    ? symbolSetter(symbol, fn)\n\t    : fn;\n\t\n\t  if (typeof data === 'object') {\n\t    if (Array.isArray(data)) {\n\t      return data.forEach(iterate, this);\n\t    }\n\t\n\t    var i = 0;\n\t    for (var key in data) {\n\t      if (data.hasOwnProperty(key)) {\n\t        iterate.call(this, {key: key, value: data[key]}, i++);\n\t      }\n\t    }\n\t  } else if (typeof data === 'string') {\n\t    return data.split('').forEach(iterate, this);\n\t  }\n\t\n\t  // throw new Error('unable to iterate over ' + (typeof data));\n\t}\n\t\n\tfunction symbolSetter(symbol, fn) {\n\t  return function(data) {\n\t    var previous = set(this, symbol, data);\n\t    fn.call(this, data);\n\t    set(this, symbol, previous);\n\t  };\n\t}\n\t\n\tfunction defined(value) {\n\t  return value !== null && value !== undefined;\n\t}\n\t\n\tfunction not(fn) {\n\t  return function() {\n\t    return !fn.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction set(context, symbol, value) {\n\t  var previous = context[symbol];\n\t  if (value === undefined) {\n\t    delete context[symbol];\n\t  } else {\n\t    context[symbol] = value;\n\t  }\n\t  return previous;\n\t}\n\t\n\tfunction noop() {\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** */\n\texports.notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Similar to the built-in Treewalker class, but simplified and allows direct\n\t * access to modify the currentNode property.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     walker should start traversing.\n\t * @constructor\n\t */\n\tfunction TreeWalker(node) {\n\t  /**\n\t   * Keeps track of the current parent node. This is necessary as the traversal\n\t   * methods may traverse past the last child and we still need a way to get\n\t   * back to the parent.\n\t   * @const @private {!Array<!Node>}\n\t   */\n\t  this.stack_ = [];\n\t\n\t  /**\n\t   * @const {!Element|!DocumentFragment}\n\t   */\n\t  this.root = node;\n\t\n\t  /**\n\t   * @type {?Node}\n\t   */\n\t  this.currentNode = node;\n\t}\n\t\n\t/**\n\t * @return {!Node} The current parent of the current location in the subtree.\n\t */\n\tTreeWalker.prototype.getCurrentParent = function () {\n\t  return this.stack_[this.stack_.length - 1];\n\t};\n\t\n\t/**\n\t * Changes the current location the firstChild of the current location.\n\t */\n\tTreeWalker.prototype.firstChild = function () {\n\t  this.stack_.push(this.currentNode);\n\t  this.currentNode = this.currentNode.firstChild;\n\t};\n\t\n\t/**\n\t * Changes the current location the nextSibling of the current location.\n\t */\n\tTreeWalker.prototype.nextSibling = function () {\n\t  this.currentNode = this.currentNode.nextSibling;\n\t};\n\t\n\t/**\n\t * Changes the current location the parentNode of the current location.\n\t */\n\tTreeWalker.prototype.parentNode = function () {\n\t  this.currentNode = this.stack_.pop();\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     is for.\n\t * @param {?Context} prevContext The previous context.\n\t * @constructor\n\t */\n\tfunction Context(node, prevContext) {\n\t  /**\n\t   * @const {TreeWalker}\n\t   */\n\t  this.walker = new TreeWalker(node);\n\t\n\t  /**\n\t   * @const {Document}\n\t   */\n\t  this.doc = node.ownerDocument;\n\t\n\t  /**\n\t   * Keeps track of what namespace to create new Elements in.\n\t   * @private\n\t   * @const {!Array<(string|undefined)>}\n\t   */\n\t  this.nsStack_ = [undefined];\n\t\n\t  /**\n\t   * @const {?Context}\n\t   */\n\t  this.prevContext = prevContext;\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = exports.notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = exports.notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @return {(string|undefined)} The current namespace to create Elements in.\n\t */\n\tContext.prototype.getCurrentNamespace = function () {\n\t  return this.nsStack_[this.nsStack_.length - 1];\n\t};\n\t\n\t/**\n\t * @param {string=} namespace The namespace to enter.\n\t */\n\tContext.prototype.enterNamespace = function (namespace) {\n\t  this.nsStack_.push(namespace);\n\t};\n\t\n\t/**\n\t * Exits the current namespace\n\t */\n\tContext.prototype.exitNamespace = function () {\n\t  this.nsStack_.pop();\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    exports.notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    exports.notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t * The current context.\n\t * @type {?Context}\n\t */\n\tvar context;\n\t\n\t/**\n\t * Enters a new patch context.\n\t * @param {!Element|!DocumentFragment} node\n\t */\n\tvar enterContext = function (node) {\n\t  context = new Context(node, context);\n\t};\n\t\n\t/**\n\t * Restores the previous patch context.\n\t */\n\tvar restoreContext = function () {\n\t  context = context.prevContext;\n\t};\n\t\n\t/**\n\t * Gets the current patch context.\n\t * @return {?Context}\n\t */\n\tvar getContext = function () {\n\t  return context;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The last child to have been visited within the current pass.\n\t   * @type {?Node}\n\t   */\n\t  this.lastVisitedChild = null;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\texports.symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\texports.applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    el.setAttribute(name, value);\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\texports.applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {string|Object<string,string>} style The style to set. Either a\n\t *     string of css or an object containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t\n\t    for (var prop in style) {\n\t      if (has(style, prop)) {\n\t        elStyle[prop] = style[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    exports.applyProp(el, name, value);\n\t  } else {\n\t    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\texports.attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\texports.attributes[exports.symbols.default] = applyAttributeTyped;\n\t\n\texports.attributes[exports.symbols.placeholder] = function () {};\n\t\n\texports.attributes['style'] = applyStyle;\n\t\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\t\n\t/**\n\t * Enters a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar enterTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    getContext().enterNamespace(SVG_NS);\n\t  } else if (tag === 'foreignObject') {\n\t    getContext().enterNamespace(undefined);\n\t  }\n\t};\n\t\n\t/**\n\t * Exits a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar exitTag = function (tag) {\n\t  if (tag === 'svg' || tag === 'foreignObject') {\n\t    getContext().exitNamespace();\n\t  }\n\t};\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @return {(string|undefined)} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    return SVG_NS;\n\t  }\n\t\n\t  return getContext().getCurrentNamespace();\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag);\n\t  var el;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Node, either a Text or an Element depending on the node name\n\t * provided.\n\t * @param {Document} doc The document with which to create the Node.\n\t * @param {string} nodeName The tag if creating an element or #text to create\n\t *     a Text.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics The static data to initialize the Node\n\t *     with. For an Element, an array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Node}\n\t */\n\tvar createNode = function (doc, nodeName, key, statics) {\n\t  if (nodeName === '#text') {\n\t    return doc.createTextNode('');\n\t  }\n\t\n\t  return createElement(doc, nodeName, key, statics);\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var children = el.children;\n\t  var count = children.length;\n\t\n\t  for (var i = 0; i < count; i += 1) {\n\t    var child = children[i];\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {!Node} parent\n\t * @param {?string=} key\n\t * @return {?Element} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n\t  );\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {!Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t  * Makes sure that keyed Element matches the tag name provided.\n\t  * @param {!Element} node The node that is being matched.\n\t  * @param {string=} tag The tag name of the Element.\n\t  * @param {?string=} key The key of the Element.\n\t  */\n\t  var assertKeyedTagMatches = function (node, tag, key) {\n\t    var nodeName = getData(node).nodeName;\n\t    if (nodeName !== tag) {\n\t      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Checks whether or not a given node matches the specified nodeName and key.\n\t *\n\t * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (node, nodeName, key) {\n\t  var data = getData(node);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return key == data.key && nodeName === data.nodeName;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t * @return {!Node} The matching node.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var currentNode = walker.currentNode;\n\t  var parent = walker.getCurrentParent();\n\t  var matchingNode;\n\t\n\t  // Check to see if we have a node to reuse\n\t  if (currentNode && matches(currentNode, nodeName, key)) {\n\t    matchingNode = currentNode;\n\t  } else {\n\t    var existingNode = getChild(parent, key);\n\t\n\t    // Check to see if the node has moved within the parent or if a new one\n\t    // should be created\n\t    if (existingNode) {\n\t      if (process.env.NODE_ENV !== 'production') {\n\t        assertKeyedTagMatches(existingNode, nodeName, key);\n\t      }\n\t\n\t      matchingNode = existingNode;\n\t    } else {\n\t      matchingNode = createNode(context.doc, nodeName, key, statics);\n\t\n\t      if (key) {\n\t        registerChild(parent, key, matchingNode);\n\t      }\n\t\n\t      context.markCreated(matchingNode);\n\t    }\n\t\n\t    // If the node has a key, remove it from the DOM to prevent a large number\n\t    // of re-orders in the case that it moved far or was completely removed.\n\t    // Since we hold on to a reference through the keyMap, we can always add it\n\t    // back.\n\t    if (currentNode && getData(currentNode).key) {\n\t      parent.replaceChild(matchingNode, currentNode);\n\t      getData(parent).keyMapValid = false;\n\t    } else {\n\t      parent.insertBefore(matchingNode, currentNode);\n\t    }\n\t\n\t    walker.currentNode = matchingNode;\n\t  }\n\t\n\t  return matchingNode;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t * @param {Node} node\n\t */\n\tvar clearUnvisitedDOM = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var lastVisitedChild = data.lastVisitedChild;\n\t  var child = node.lastChild;\n\t  var key;\n\t\n\t  data.lastVisitedChild = null;\n\t\n\t  if (child === lastVisitedChild && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n\t    return;\n\t  }\n\t\n\t  while (child !== lastVisitedChild) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  for (key in keyMap) {\n\t    child = keyMap[key];\n\t    if (!child.parentNode) {\n\t      context.markDeleted(child);\n\t      delete keyMap[key];\n\t    }\n\t  }\n\t\n\t  data.keyMapValid = true;\n\t};\n\t\n\t/**\n\t * Enters an Element, setting the current namespace for nested elements.\n\t * @param {Node} node\n\t */\n\tvar enterNode = function (node) {\n\t  var data = getData(node);\n\t  enterTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Exits an Element, unwinding the current namespace to the previous value.\n\t * @param {Node} node\n\t */\n\tvar exitNode = function (node) {\n\t  var data = getData(node);\n\t  exitTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Marks node's parent as having visited node.\n\t * @param {Node} node\n\t */\n\tvar markVisited = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var parent = walker.getCurrentParent();\n\t  var data = getData(parent);\n\t  data.lastVisitedChild = node;\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar firstChild = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  enterNode(walker.currentNode);\n\t  walker.firstChild();\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextSibling = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  markVisited(walker.currentNode);\n\t  walker.nextSibling();\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar parentNode = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  walker.parentNode();\n\t  exitNode(walker.currentNode);\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  var assertNoUnclosedTags = function (root) {\n\t    var openElement = getContext().walker.getCurrentParent();\n\t    if (!openElement) {\n\t      return;\n\t    }\n\t\n\t    var openTags = [];\n\t    while (openElement && openElement !== root) {\n\t      openTags.push(openElement.nodeName.toLowerCase());\n\t      openElement = openElement.parentNode;\n\t    }\n\t\n\t    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n\t  };\n\t}\n\t\n\t/**\n\t * Patches the document starting at el with the provided function. This function\n\t * may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\texports.patch = function (node, fn, data) {\n\t  enterContext(node);\n\t\n\t  firstChild();\n\t  fn(data);\n\t  parentNode();\n\t  clearUnvisitedDOM(node);\n\t\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNoUnclosedTags(node);\n\t  }\n\t\n\t  getContext().notifyChanges();\n\t  restoreContext();\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t   * Keeps track whether or not we are in an attributes declaration (after\n\t   * elementOpenStart, but before elementOpenEnd).\n\t   * @type {boolean}\n\t   */\n\t  var inAttributes = false;\n\t\n\t  /** Makes sure that the caller is not where attributes are expected. */\n\t  var assertNotInAttributes = function () {\n\t    if (inAttributes) {\n\t      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n\t    }\n\t  };\n\t\n\t  /** Makes sure that the caller is where attributes are expected. */\n\t  var assertInAttributes = function () {\n\t    if (!inAttributes) {\n\t      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that placeholders have a key specified. Otherwise, conditional\n\t   * placeholders and conditional elements next to placeholders will cause\n\t   * placeholder elements to be re-used as non-placeholders and vice versa.\n\t   * @param {string} key\n\t   */\n\t  var assertPlaceholderKeySpecified = function (key) {\n\t    if (!key) {\n\t      throw new Error('Placeholder elements must have a key specified.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that tags are correctly nested.\n\t   * @param {string} tag\n\t   */\n\t  var assertCloseMatchesOpenTag = function (tag) {\n\t    var context = getContext();\n\t    var walker = context.walker;\n\t    var closingNode = walker.getCurrentParent();\n\t    var data = getData(closingNode);\n\t\n\t    if (tag !== data.nodeName) {\n\t      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n\t    }\n\t  };\n\t\n\t  /** Updates the state to being in an attribute declaration. */\n\t  var setInAttributes = function () {\n\t    inAttributes = true;\n\t  };\n\t\n\t  /** Updates the state to not being in an attribute declaration. */\n\t  var setNotInAttributes = function () {\n\t    inAttributes = false;\n\t  };\n\t}\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpen = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    var attr,\n\t        newAttrs = data.newAttrs;\n\t\n\t    for (attr in newAttrs) {\n\t      newAttrs[attr] = undefined;\n\t    }\n\t\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (attr in newAttrs) {\n\t      updateAttribute(node, attr, newAttrs[attr]);\n\t    }\n\t  }\n\t\n\t  firstChild();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\texports.elementOpenStart = function (tag, key, statics) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    setInAttributes();\n\t  }\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\texports.attr = function (name, value) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t  }\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpenEnd = function () {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t    setNotInAttributes();\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementClose = function (tag) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    assertCloseMatchesOpenTag(tag);\n\t  }\n\t\n\t  parentNode();\n\t\n\t  var node = /** @type {!Element} */getContext().walker.currentNode;\n\t\n\t  clearUnvisitedDOM(node);\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementVoid = function (tag, key, statics, var_args) {\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementPlaceholder = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertPlaceholderKeySpecified(key);\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  updateAttribute(node, exports.symbols.placeholder, true);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} var_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\texports.text = function (value, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      formatted = arguments[i](formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar style = function(getter) {\n\t  return function() {\n\t    var data = getter.apply(this, arguments);\n\t    if (data && typeof data === 'object') {\n\t      return formatStyle(data);\n\t    }\n\t    return data;\n\t  };\n\t};\n\t\n\tvar className = function(getter) {\n\t  return function() {\n\t    var data = getter.apply(this, arguments);\n\t    if (data && typeof data === 'object') {\n\t      return formatClassName(data);\n\t    }\n\t    return data;\n\t  };\n\t};\n\t\n\tmodule.exports = {\n\t  style: style,\n\t  className: className\n\t};\n\t\n\tfunction formatStyle(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join('; ');\n\t  }\n\t  return Object.keys(obj)\n\t    .map(function(key) {\n\t      return [\n\t        reformatCamelCase(key),\n\t        ': ',\n\t        obj[key],\n\t        ';'\n\t      ].join('');\n\t    })\n\t    .join(' ');\n\t}\n\t\n\tfunction reformatCamelCase(str) {\n\t  return str.replace(/[A-Z]/g, function(char) {\n\t    return '-' + char.toLowerCase();\n\t  });\n\t}\n\t\n\tfunction formatClassName(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t  return Object.keys(obj).filter(function(key) {\n\t    return !!obj[key];\n\t  }).join(' ');\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar evaluate = __webpack_require__(4).evaluate;\n\t\n\tmodule.exports = interpolate;\n\t\n\tfunction interpolate(template, data) {\n\t  var that = this;\n\t  return template.replace(/{{([^}]+)}}/g, function(_, expr) {\n\t    return evaluate.call(that, expr, data);\n\t  });\n\t}\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c752303c182827b82f46\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar render = require('./render');\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: render.create,\n  render: render.render\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*! (C) WebReflection Mit Style License */\n(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/document-register-element/build/document-register-element.js\n ** module id = 1\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render').create;\n\nvar RENDER = '__render';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        console.log('attached!', this);\n        this.update();\n      }},\n\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      render: {value: function(data) {\n        if (!arguments.length) data = this.data;\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      invalidate: {value: function() {\n        this[RENDER] = null;\n        this.render();\n      }},\n\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function property(read, write, value) {\n  return {\n    enumerable: false,\n\n    get: function() {\n      return read ? read.call(this, value) : value;\n    },\n\n    set: function(v) {\n      if (v !== value) {\n        var previous = value;\n        return value = write.call(this, v, previous);\n      }\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 3\n ** module chunks = 0\n **/","var arrow = require('./arrow');\n\nvar evaluate = function(expression, data) {\n  var fn = evaluator(expression);\n  return fn.call(this, data);\n};\n\nvar evaluator = function(expression) {\n  if (arrow.is(expression)) {\n    return parseArrow(expression);\n  }\n\n  var symbol = 'd' + Date.now();\n  // '.' is just the identity function\n  if (expression === '.') {\n    return function identity(d) { return d; };\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    '  with (this) {',\n    '    with (', symbol, ') {',\n    '      return ', expression, ';',\n    '    } ',\n    '  } ',\n    '} catch (error) { }'\n  ].join(''));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator,\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 4\n ** module chunks = 0\n **/","var ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = match[4] || match[5];\n  return new Function(args, 'return (' + body + ')');\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 5\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar incremental = require('incremental-dom');\nvar xp = require('./evaluate');\nvar interpolate = require('./interpolate');\nvar transform = require('./transform');\n\n// our attribute namespace\nvar T_NS = 't-';\n\nvar T_AS = T_NS + 'as';\nvar T_SKIP = T_NS + 'skip';\nvar T_IF = T_NS + 'if';\nvar T_ELSE = T_NS + 'else';\nvar T_EACH = T_NS + 'each';\nvar T_FOREACH = T_NS + 'foreach';\nvar T_WITH = T_NS + 'with';\nvar T_TEXT = T_NS + 'text';\n\nvar CONTROL_ATTRS = [\n  'if',\n  'else',\n  'each',\n  'foreach',\n  'with',\n  'text',\n  'as',\n  'skip'\n];\n\nvar VOID_ELEMENTS = [\n  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n  'wbr'\n];\n\nmodule.exports = {\n  create: createRenderFunction,\n  render: function(root, data, context) {\n    var render = createRenderFunction(root, context);\n    render(data);\n    return render;\n  }\n};\n\nfunction createRenderFunction(root, context) {\n  if (typeof root === 'string') {\n    var selector = root;\n    root = document.querySelector(selector);\n    if (!root) {\n      throw new Error('no element found with selector: \"' + selector + '\"');\n    }\n  }\n  var render = createRenderer(root);\n  if (arguments.length < 2) context = {};\n  return function _render(data) {\n    // console.log('rendering with data:', data);\n    return incremental.patch(root, render.bind(context, data));\n  };\n}\n\nfunction createRenderer(root) {\n  var calls = [];\n  for (\n    var child = root.firstChild; child;\n    child = child.nextSibling\n  ) {\n    switch (child.nodeType) {\n      case Node.TEXT_NODE:\n        calls.push(createTextRenderer(child));\n        break;\n      case Node.ELEMENT_NODE:\n        calls.push(createElementRenderer(child));\n        break;\n    }\n  }\n  return function patch(data) {\n    // console.log('patching:', root, 'with', data);\n    calls.forEach(function(fn) {\n      fn.call(this, data);\n    }, this);\n  };\n}\n\nfunction createTextRenderer(node) {\n  var template = node.nodeValue;\n  return function(data) {\n    var text = interpolate.call(this, template, data);\n    incremental.text(defined(text) ? text : '');\n  };\n}\n\nfunction createElementRenderer(node) {\n  var name = node.nodeName.toLowerCase();\n\n  // this element will never be rendered if it has a truthy t-skip attribute\n  if (node.hasAttribute(T_SKIP)) {\n    return noop;\n  }\n\n  var isVoid = isElementVoid(name);\n  var attrMap = getAttributeMap(node);\n\n  var condition = node.hasAttribute(T_IF)\n    ? xp.evaluator(node.getAttribute(T_IF))\n    : null;\n\n  if (node.hasAttribute(T_ELSE)) {\n    if (condition) throw new Error('element has both t-if and t-else attributes');\n    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n    if (!ifSibling) throw new Error('element with t-else has no matching t-if sibling');\n    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n  }\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  var textExpression = node.getAttribute(T_TEXT);\n  if (textExpression) {\n    var getText = xp.evaluator(textExpression);\n    renderChildren = function(data) {\n      var value = getText.call(this, data);\n      if (defined(value)) {\n        incremental.text(String(value));\n      }\n    };\n  } else {\n    renderChildren = createRenderer(node);\n  }\n\n  var render = function(data) {\n    // console.log('rendering', node, 'with data:', data);\n    if (condition && !condition.call(this, data)) {\n      return false;\n    }\n\n    var attrs = interpolateAttributes.call(this, attrMap, data);\n    if (isVoid) {\n      incremental.elementVoid(name, '', attrs);\n    } else {\n      incremental.elementOpen(name, '', attrs);\n      renderChildren.call(this, data);\n      incremental.elementClose(name);\n    }\n  };\n\n  var eachExpression = node.getAttribute(T_EACH);\n  var forEachExpression = node.getAttribute(T_FOREACH);\n  var withExpression = node.getAttribute(T_WITH);\n\n  var symbol = node.getAttribute(T_AS);\n\n  if (eachExpression) {\n    render = renderEach(eachExpression, render, symbol);\n  } else if (forEachExpression) {\n    renderChildren = renderEach(forEachExpression, renderChildren, symbol);\n  } else if (withExpression) {\n    render = renderWith(withExpression, render, symbol);\n  } else if (symbol) {\n    render = symbolSetter(symbol, render);\n  }\n\n  return render;\n}\n\nfunction renderEach(expression, render, symbol) {\n  var expr = xp.evaluator(expression);\n  return function(data) {\n    var values = expr.call(this, data);\n    forEach.call(this, values, render, symbol);\n  };\n}\n\nfunction renderWith(expression, render, symbol) {\n  var expr = xp.evaluator(expression);\n  if (symbol) render = symbolSetter(symbol, render);\n  return function(data) {\n    data = expr.call(this, data);\n    render.call(this, data);\n  };\n}\n\nfunction getAttributeMap(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = String(attr.name);\n    if (name.indexOf(T_NS) === 0) {\n      name = name.substr(T_NS.length);\n      if (CONTROL_ATTRS.indexOf(name) > -1) {\n        break;\n      }\n      var getter = xp.evaluator(attr.value);\n      switch (name) {\n        case 'class':\n          getter = transform.className(getter);\n          break;\n        case 'style':\n          getter = transform.style(getter);\n          break;\n      }\n      map[name] = getter;\n    } else {\n      map[name] = attr.value;\n    }\n  }\n  return map;\n}\n\nfunction interpolateAttributes(attrMap, data) {\n  var attrs = [];\n  for (var key in attrMap) {\n    var value = attrMap[key];\n    if (typeof value === 'function') {\n      value = value.call(this, data, key);\n    }\n    if (defined(value)) {\n      attrs.push(key, value);\n    }\n  }\n  return attrs;\n}\n\nfunction getPreviousSibling(node, selector) {\n  while (node = node.previousSibling) {\n    if (!node) break;\n    // FIXME this needs a vendor prefix in IE 9+\n    // <http://caniuse.com/#search=matches>\n    if (node.matches(selector)) return node;\n  }\n  throw new Error('no previous sibling found matching: ' + selector);\n}\n\nfunction isElementVoid(name) {\n  return VOID_ELEMENTS.indexOf(name) > -1;\n}\n\nfunction forEach(data, fn, symbol) {\n  var previous;\n  var iterate = symbol\n    ? symbolSetter(symbol, fn)\n    : fn;\n\n  if (typeof data === 'object') {\n    if (Array.isArray(data)) {\n      return data.forEach(iterate, this);\n    }\n\n    var i = 0;\n    for (var key in data) {\n      if (data.hasOwnProperty(key)) {\n        iterate.call(this, {key: key, value: data[key]}, i++);\n      }\n    }\n  } else if (typeof data === 'string') {\n    return data.split('').forEach(iterate, this);\n  }\n\n  // throw new Error('unable to iterate over ' + (typeof data));\n}\n\nfunction symbolSetter(symbol, fn) {\n  return function(data) {\n    var previous = set(this, symbol, data);\n    fn.call(this, data);\n    set(this, symbol, previous);\n  };\n}\n\nfunction defined(value) {\n  return value !== null && value !== undefined;\n}\n\nfunction not(fn) {\n  return function() {\n    return !fn.apply(this, arguments);\n  };\n}\n\nfunction set(context, symbol, value) {\n  var previous = context[symbol];\n  if (value === undefined) {\n    delete context[symbol];\n  } else {\n    context[symbol] = value;\n  }\n  return previous;\n}\n\nfunction noop() {\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 6\n ** module chunks = 0\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     walker should start traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /**\n   * @const {!Element|!DocumentFragment}\n   */\n  this.root = node;\n\n  /**\n   * @type {?Node}\n   */\n  this.currentNode = node;\n}\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function () {\n  return this.stack_[this.stack_.length - 1];\n};\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function () {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function () {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function () {\n  this.currentNode = this.stack_.pop();\n};\n\n/**\n * Keeps track of the state of a patch.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     is for.\n * @param {?Context} prevContext The previous context.\n * @constructor\n */\nfunction Context(node, prevContext) {\n  /**\n   * @const {TreeWalker}\n   */\n  this.walker = new TreeWalker(node);\n\n  /**\n   * @const {Document}\n   */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @private\n   * @const {!Array<(string|undefined)>}\n   */\n  this.nsStack_ = [undefined];\n\n  /**\n   * @const {?Context}\n   */\n  this.prevContext = prevContext;\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n/**\n * @return {(string|undefined)} The current namespace to create Elements in.\n */\nContext.prototype.getCurrentNamespace = function () {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n/**\n * @param {string=} namespace The namespace to enter.\n */\nContext.prototype.enterNamespace = function (namespace) {\n  this.nsStack_.push(namespace);\n};\n\n/**\n * Exits the current namespace\n */\nContext.prototype.exitNamespace = function () {\n  this.nsStack_.pop();\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * The current context.\n * @type {?Context}\n */\nvar context;\n\n/**\n * Enters a new patch context.\n * @param {!Element|!DocumentFragment} node\n */\nvar enterContext = function (node) {\n  context = new Context(node, context);\n};\n\n/**\n * Restores the previous patch context.\n */\nvar restoreContext = function () {\n  context = context.prevContext;\n};\n\n/**\n * Gets the current patch context.\n * @return {?Context}\n */\nvar getContext = function () {\n  return context;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * @type {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {string|Object<string,string>} style The style to set. Either a\n *     string of css or an object containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n\n    for (var prop in style) {\n      if (has(style, prop)) {\n        elStyle[prop] = style[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function () {};\n\nexports.attributes['style'] = applyStyle;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function (tag) {\n  if (tag === 'svg') {\n    getContext().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getContext().enterNamespace(undefined);\n  }\n};\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function (tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getContext().exitNamespace();\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {(string|undefined)} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getContext().getCurrentNamespace();\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function (doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Node} parent\n * @param {?string=} key\n * @return {?Element} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n  );\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!Element} node The node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function (node, tag, key) {\n    var nodeName = getData(node).nodeName;\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n    }\n  };\n}\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key && nodeName === data.nodeName;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  var context = getContext();\n  var walker = context.walker;\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(existingNode, nodeName, key);\n      }\n\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(context.doc, nodeName, key, statics);\n\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n\n      context.markCreated(matchingNode);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      parent.replaceChild(matchingNode, currentNode);\n      getData(parent).keyMapValid = false;\n    } else {\n      parent.insertBefore(matchingNode, currentNode);\n    }\n\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {Node} node\n */\nvar clearUnvisitedDOM = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var lastVisitedChild = data.lastVisitedChild;\n  var child = node.lastChild;\n  var key;\n\n  data.lastVisitedChild = null;\n\n  if (child === lastVisitedChild && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n    return;\n  }\n\n  while (child !== lastVisitedChild) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  for (key in keyMap) {\n    child = keyMap[key];\n    if (!child.parentNode) {\n      context.markDeleted(child);\n      delete keyMap[key];\n    }\n  }\n\n  data.keyMapValid = true;\n};\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {Node} node\n */\nvar enterNode = function (node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {Node} node\n */\nvar exitNode = function (node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n/**\n * Marks node's parent as having visited node.\n * @param {Node} node\n */\nvar markVisited = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function () {\n  var context = getContext();\n  var walker = context.walker;\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function () {\n  var context = getContext();\n  var walker = context.walker;\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function () {\n  var context = getContext();\n  var walker = context.walker;\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function (root) {\n    var openElement = getContext().walker.getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n  };\n}\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function (node, fn, data) {\n  enterContext(node);\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  getContext().notifyChanges();\n  restoreContext();\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function () {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n    }\n  };\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function () {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n    }\n  };\n\n  /**\n   * Makes sure that placeholders have a key specified. Otherwise, conditional\n   * placeholders and conditional elements next to placeholders will cause\n   * placeholder elements to be re-used as non-placeholders and vice versa.\n   * @param {string} key\n   */\n  var assertPlaceholderKeySpecified = function (key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function (tag) {\n    var context = getContext();\n    var walker = context.walker;\n    var closingNode = walker.getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n    }\n  };\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function () {\n    inAttributes = true;\n  };\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function () {\n    inAttributes = false;\n  };\n}\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var attr,\n        newAttrs = data.newAttrs;\n\n    for (attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = /** @type {!Element} */getContext().walker.currentNode;\n\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function (tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  var node = exports.elementOpen.apply(null, arguments);\n  updateAttribute(node, exports.symbols.placeholder, true);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n  return node;\n};\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/dist/incremental-dom-cjs.js\n ** module id = 7\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 8\n ** module chunks = 0\n **/","var style = function(getter) {\n  return function() {\n    var data = getter.apply(this, arguments);\n    if (data && typeof data === 'object') {\n      return formatStyle(data);\n    }\n    return data;\n  };\n};\n\nvar className = function(getter) {\n  return function() {\n    var data = getter.apply(this, arguments);\n    if (data && typeof data === 'object') {\n      return formatClassName(data);\n    }\n    return data;\n  };\n};\n\nmodule.exports = {\n  style: style,\n  className: className\n};\n\nfunction formatStyle(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join('; ');\n  }\n  return Object.keys(obj)\n    .map(function(key) {\n      return [\n        reformatCamelCase(key),\n        ': ',\n        obj[key],\n        ';'\n      ].join('');\n    })\n    .join(' ');\n}\n\nfunction reformatCamelCase(str) {\n  return str.replace(/[A-Z]/g, function(char) {\n    return '-' + char.toLowerCase();\n  });\n}\n\nfunction formatClassName(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n  return Object.keys(obj).filter(function(key) {\n    return !!obj[key];\n  }).join(' ');\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/transform.js\n ** module id = 9\n ** module chunks = 0\n **/","var evaluate = require('./evaluate').evaluate;\n\nmodule.exports = interpolate;\n\nfunction interpolate(template, data) {\n  var that = this;\n  return template.replace(/{{([^}]+)}}/g, function(_, expr) {\n    return evaluate.call(that, expr, data);\n  });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/interpolate.js\n ** module id = 10\n ** module chunks = 0\n **/"],"sourceRoot":""}
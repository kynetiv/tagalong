{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap b241b280923dbda71c9e","webpack:///./src/main.js","webpack:///./~/document-register-element/build/document-register-element.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/render.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Template","createRenderer","render","node","data","_render","window","tagalong","e","t","n","r","rt","length","dt","it","nt","b","ot","st","j","querySelectorAll","w","getAttribute","nodeName","toUpperCase","S","y","v","d","ut","indexOf","at","currentTarget","attrChange","attrName","i","target","Q","attributeChangedCallback","a","prevValue","l","newValue","ft","X","push","lt","K","removeEventListener","h","detail","o","s","B","pt","ct","this","q","G","ht","D","et","observe","z","J","setAttribute","Z","addEventListener","createdCallback","created","F","E","contains","splice","tt","Y","Math","random","u","f","g","documentElement","x","prototype","T","hasOwnProperty","N","isPrototypeOf","C","defineProperty","k","getOwnPropertyDescriptor","L","getOwnPropertyNames","A","getPrototypeOf","O","setPrototypeOf","M","__proto__","_","create","vt","P","MutationObserver","WebKitMutationObserver","H","HTMLElement","Element","Node","nodeType","I","cloneNode","R","removeAttribute","U","createElement","attributes","characterData","attributeOldValue","W","V","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","$","value","CustomEvent","bubbles","dispatchEvent","hasAttribute","propertyName","name","className","type","addedNodes","removedNodes","attributeName","oldValue","childList","subtree","shift","apply","arguments","toLowerCase","innerHTMLHelper","Error","test","concat","document","Object","property","evaluate","RENDER","DATA_ATTR","registerElement","attachedCallback","console","log","update","attr","previous","expr","invalidate","read","write","enumerable","get","set","arrow","expression","context","fn","evaluator","is","parseArrow","symbol","Date","now","match","Function","join","ARROW_PATTERN","isArrow","String","args","body","parse","createRenderFunction","root","incremental","patch","bind","calls","child","firstChild","nextSibling","TEXT_NODE","createTextRenderer","ELEMENT_NODE","createElementRenderer","forEach","text","nodeValue","renderChildren","isVoid","isElementVoid","attrMap","getAttributeMap","condition","T_IF","xp","textExpression","T_TEXT","getText","undefined","attrs","interpolateAttributes","elementVoid","elementOpen","elementClose","eachExpression","T_EACH","forEachExpression","T_FOREACH","renderEach","values","map","CONTROL_ATTRS","T_NAMESPACE","getter","substr","key","VOID_ELEMENTS","process","TreeWalker","stack_","currentNode","Context","prevContext","walker","doc","ownerDocument","nsStack_","notifications","nodesCreated","deleted","nodesDeleted","NodeData","createMap","attrsArr","newAttrs","keyMap","keyMapValid","lastVisitedChild","getCurrentParent","parentNode","pop","getCurrentNamespace","enterNamespace","namespace","exitNamespace","markCreated","markDeleted","notifyChanges","enterContext","restoreContext","getContext","has","initData","getData","symbols","default","placeholder","applyAttr","el","applyProp","applyStyle","style","cssText","elStyle","prop","applyAttributeTyped","updateAttribute","mutator","SVG_NS","enterTag","tag","exitTag","getNamespaceForTag","statics","createElementNS","createNode","createTextNode","createKeyMap","children","count","getKeyMap","getChild","parent","registerChild","env","NODE_ENV","assertKeyedTagMatches","matches","alignWithDOM","matchingNode","existingNode","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","enterNode","exitNode","markVisited","assertNoUnclosedTags","openElement","openTags","ATTRIBUTES_OFFSET","argsBuilder","inAttributes","assertNotInAttributes","assertInAttributes","assertPlaceholderKeySpecified","assertCloseMatchesOpenTag","closingNode","setInAttributes","setNotInAttributes","var_args","attrsChanged","elementOpenStart","elementOpenEnd","elementPlaceholder","formatted","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","clearTimeout","Item","fun","array","noop","nextTick","Array","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t\n\tvar Template = __webpack_require__(2);\n\tvar createRenderer = __webpack_require__(6);\n\t\n\tvar render = function(node, data) {\n\t  var _render = createRenderer(node);\n\t  _render(data);\n\t  return _render;\n\t};\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: createRenderer,\n\t  render: render\n\t};\n\t\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*! (C) WebReflection Mit Style License */\n\t(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(3);\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar createRenderer = __webpack_require__(6);\n\t\n\tvar RENDER = '__render';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        console.log('attached!', this);\n\t        this.update();\n\t      }},\n\t\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      render: {value: function(data) {\n\t        if (!arguments.length) data = this.data;\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t        this.render();\n\t      }},\n\t\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, value) {\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      return read ? read.call(this, value) : value;\n\t    },\n\t\n\t    set: function(v) {\n\t      if (v !== value) {\n\t        var previous = value;\n\t        return value = write.call(this, v, previous);\n\t      }\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrow = __webpack_require__(5);\n\t\n\tvar evaluate = function(expression, context) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, context);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (arrow.is(expression)) {\n\t    return parseArrow(expression);\n\t  }\n\t\n\t  var symbol = 'd' + Date.now();\n\t  // '.' is just the identity function\n\t  if (expression === '.') {\n\t    return function identity(d) { return d; };\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    'with (', symbol, ' || {}) {',\n\t    '  return ', expression, ';',\n\t    '} ',\n\t    '} catch (error) { }'\n\t  ].join(''));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator,\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = match[4] || match[5];\n\t  return new Function(args, 'return (' + body + ')');\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar incremental = __webpack_require__(7);\n\tvar xp = __webpack_require__(4);\n\t\n\tvar T_NAMESPACE = 't-';\n\tvar T_IF = T_NAMESPACE + 'if';\n\tvar T_EACH = T_NAMESPACE + 'each';\n\tvar T_TEXT = T_NAMESPACE + 'text';\n\tvar T_FOREACH = T_NAMESPACE + 'foreach';\n\t\n\tvar CONTROL_ATTRS = [T_IF, T_EACH, T_FOREACH, T_TEXT];\n\t\n\tvar VOID_ELEMENTS = [\n\t  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n\t  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n\t  'wbr'\n\t];\n\t\n\tmodule.exports = createRenderFunction;\n\t\n\tfunction createRenderFunction(root) {\n\t  var render = createRenderer(root);\n\t  return function _render(data) {\n\t    // console.log('rendering with data:', data);\n\t    return incremental.patch(root, render.bind(this, data));\n\t  };\n\t}\n\t\n\tfunction createRenderer(root) {\n\t  var calls = [];\n\t  for (\n\t    var child = root.firstChild; child;\n\t    child = child.nextSibling\n\t  ) {\n\t    switch (child.nodeType) {\n\t      case Node.TEXT_NODE:\n\t        calls.push(createTextRenderer(child));\n\t        break;\n\t      case Node.ELEMENT_NODE:\n\t        calls.push(createElementRenderer(child));\n\t        break;\n\t    }\n\t  }\n\t  return function patch(data) {\n\t    // console.log('patching:', root, 'with', data);\n\t    calls.forEach(function(fn) {\n\t      fn(data);\n\t    });\n\t  };\n\t}\n\t\n\tfunction createTextRenderer(node) {\n\t  // TODO: expand {{ expressions }} ?\n\t  return function(data) {\n\t    incremental.text(node.nodeValue);\n\t  };\n\t}\n\t\n\tfunction createElementRenderer(node) {\n\t  var name = node.nodeName.toLowerCase();\n\t\n\t  var isVoid = isElementVoid(name);\n\t  var attrMap = getAttributeMap(node);\n\t\n\t  var condition = node.hasAttribute(T_IF)\n\t    ? xp.evaluator(node.getAttribute(T_IF))\n\t    : null;\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  var textExpression = node.getAttribute(T_TEXT);\n\t  if (textExpression) {\n\t    var getText = xp.evaluator(textExpression);\n\t    renderChildren = function(data) {\n\t      var value = getText(data);\n\t      if (value !== null && value !== undefined) {\n\t        incremental.text(String(value));\n\t      }\n\t    };\n\t  } else {\n\t    renderChildren = createRenderer(node);\n\t  }\n\t\n\t  var render = function(data) {\n\t    // console.log('rendering', node, 'with data:', data);\n\t    if (condition && !condition(data)) {\n\t      return false;\n\t    }\n\t\n\t    var attrs = interpolateAttributes(attrMap, data);\n\t    if (isVoid) {\n\t      incremental.elementVoid(name, '', attrs);\n\t    } else {\n\t      incremental.elementOpen(name, '', attrs);\n\t      renderChildren(data);\n\t      incremental.elementClose(name);\n\t    }\n\t  };\n\t\n\t  var eachExpression = node.getAttribute(T_EACH);\n\t  var forEachExpression = node.getAttribute(T_FOREACH);\n\t\n\t  // <ul><li t-each=\"items\">{{ . }}</li></ul>\n\t  if (eachExpression) {\n\t    // console.info('render each:', node, eachExpression);\n\t    render = renderEach(eachExpression, render);\n\t  // <ul t-foreach=\"items\"><li>{{ . }}</li></ul>\n\t  } else if (forEachExpression) {\n\t    // console.info('render foreach:', node, forEachExpression);\n\t    renderChildren = renderEach(forEachExpression, renderChildren);\n\t  } else {\n\t    // console.info('render once:', node);\n\t  }\n\t\n\t  return render;\n\t}\n\t\n\tfunction renderEach(expression, render) {\n\t  return function(data) {\n\t    var values = xp.evaluate(expression, data);\n\t    forEach(values, render);\n\t  };\n\t}\n\t\n\tfunction getAttributeMap(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = String(attr.name);\n\t    if (CONTROL_ATTRS.indexOf(name) > -1) {\n\t      // console.info('skipping control attribute', name, 'for', node);\n\t      continue;\n\t    } else if (name.indexOf(T_NAMESPACE) === 0) {\n\t      var getter = xp.evaluator(attr.value);\n\t      map[name.substr(T_NAMESPACE.length)] = getter;\n\t    } else {\n\t      map[name] = attr.value;\n\t    }\n\t  }\n\t  return map;\n\t}\n\t\n\tfunction interpolateAttributes(attrMap, data) {\n\t  var attrs = [];\n\t  for (var key in attrMap) {\n\t    var value = attrMap[key];\n\t    attrs.push(key, (typeof value === 'function')\n\t      ? value(data, key)\n\t      : String(value));\n\t  }\n\t  return attrs;\n\t}\n\t\n\tfunction isElementVoid(name) {\n\t  return VOID_ELEMENTS.indexOf(name) > -1;\n\t}\n\t\n\tfunction forEach(data, fn) {\n\t  return data.forEach(fn, this);\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** */\n\texports.notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Similar to the built-in Treewalker class, but simplified and allows direct\n\t * access to modify the currentNode property.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     walker should start traversing.\n\t * @constructor\n\t */\n\tfunction TreeWalker(node) {\n\t  /**\n\t   * Keeps track of the current parent node. This is necessary as the traversal\n\t   * methods may traverse past the last child and we still need a way to get\n\t   * back to the parent.\n\t   * @const @private {!Array<!Node>}\n\t   */\n\t  this.stack_ = [];\n\t\n\t  /**\n\t   * @const {!Element|!DocumentFragment}\n\t   */\n\t  this.root = node;\n\t\n\t  /**\n\t   * @type {?Node}\n\t   */\n\t  this.currentNode = node;\n\t}\n\t\n\t/**\n\t * @return {!Node} The current parent of the current location in the subtree.\n\t */\n\tTreeWalker.prototype.getCurrentParent = function () {\n\t  return this.stack_[this.stack_.length - 1];\n\t};\n\t\n\t/**\n\t * Changes the current location the firstChild of the current location.\n\t */\n\tTreeWalker.prototype.firstChild = function () {\n\t  this.stack_.push(this.currentNode);\n\t  this.currentNode = this.currentNode.firstChild;\n\t};\n\t\n\t/**\n\t * Changes the current location the nextSibling of the current location.\n\t */\n\tTreeWalker.prototype.nextSibling = function () {\n\t  this.currentNode = this.currentNode.nextSibling;\n\t};\n\t\n\t/**\n\t * Changes the current location the parentNode of the current location.\n\t */\n\tTreeWalker.prototype.parentNode = function () {\n\t  this.currentNode = this.stack_.pop();\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n\t *     is for.\n\t * @param {?Context} prevContext The previous context.\n\t * @constructor\n\t */\n\tfunction Context(node, prevContext) {\n\t  /**\n\t   * @const {TreeWalker}\n\t   */\n\t  this.walker = new TreeWalker(node);\n\t\n\t  /**\n\t   * @const {Document}\n\t   */\n\t  this.doc = node.ownerDocument;\n\t\n\t  /**\n\t   * Keeps track of what namespace to create new Elements in.\n\t   * @private\n\t   * @const {!Array<(string|undefined)>}\n\t   */\n\t  this.nsStack_ = [undefined];\n\t\n\t  /**\n\t   * @const {?Context}\n\t   */\n\t  this.prevContext = prevContext;\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = exports.notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = exports.notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @return {(string|undefined)} The current namespace to create Elements in.\n\t */\n\tContext.prototype.getCurrentNamespace = function () {\n\t  return this.nsStack_[this.nsStack_.length - 1];\n\t};\n\t\n\t/**\n\t * @param {string=} namespace The namespace to enter.\n\t */\n\tContext.prototype.enterNamespace = function (namespace) {\n\t  this.nsStack_.push(namespace);\n\t};\n\t\n\t/**\n\t * Exits the current namespace\n\t */\n\tContext.prototype.exitNamespace = function () {\n\t  this.nsStack_.pop();\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    exports.notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    exports.notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t * The current context.\n\t * @type {?Context}\n\t */\n\tvar context;\n\t\n\t/**\n\t * Enters a new patch context.\n\t * @param {!Element|!DocumentFragment} node\n\t */\n\tvar enterContext = function (node) {\n\t  context = new Context(node, context);\n\t};\n\t\n\t/**\n\t * Restores the previous patch context.\n\t */\n\tvar restoreContext = function () {\n\t  context = context.prevContext;\n\t};\n\t\n\t/**\n\t * Gets the current patch context.\n\t * @return {?Context}\n\t */\n\tvar getContext = function () {\n\t  return context;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The last child to have been visited within the current pass.\n\t   * @type {?Node}\n\t   */\n\t  this.lastVisitedChild = null;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\texports.symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\texports.applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    el.setAttribute(name, value);\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\texports.applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {string|Object<string,string>} style The style to set. Either a\n\t *     string of css or an object containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t\n\t    for (var prop in style) {\n\t      if (has(style, prop)) {\n\t        elStyle[prop] = style[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    exports.applyProp(el, name, value);\n\t  } else {\n\t    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\texports.attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\texports.attributes[exports.symbols.default] = applyAttributeTyped;\n\t\n\texports.attributes[exports.symbols.placeholder] = function () {};\n\t\n\texports.attributes['style'] = applyStyle;\n\t\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\t\n\t/**\n\t * Enters a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar enterTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    getContext().enterNamespace(SVG_NS);\n\t  } else if (tag === 'foreignObject') {\n\t    getContext().enterNamespace(undefined);\n\t  }\n\t};\n\t\n\t/**\n\t * Exits a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar exitTag = function (tag) {\n\t  if (tag === 'svg' || tag === 'foreignObject') {\n\t    getContext().exitNamespace();\n\t  }\n\t};\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @return {(string|undefined)} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag) {\n\t  if (tag === 'svg') {\n\t    return SVG_NS;\n\t  }\n\t\n\t  return getContext().getCurrentNamespace();\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag);\n\t  var el;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Node, either a Text or an Element depending on the node name\n\t * provided.\n\t * @param {Document} doc The document with which to create the Node.\n\t * @param {string} nodeName The tag if creating an element or #text to create\n\t *     a Text.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics The static data to initialize the Node\n\t *     with. For an Element, an array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Node}\n\t */\n\tvar createNode = function (doc, nodeName, key, statics) {\n\t  if (nodeName === '#text') {\n\t    return doc.createTextNode('');\n\t  }\n\t\n\t  return createElement(doc, nodeName, key, statics);\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var children = el.children;\n\t  var count = children.length;\n\t\n\t  for (var i = 0; i < count; i += 1) {\n\t    var child = children[i];\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {!Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {!Node} parent\n\t * @param {?string=} key\n\t * @return {?Element} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n\t  );\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {!Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t  * Makes sure that keyed Element matches the tag name provided.\n\t  * @param {!Element} node The node that is being matched.\n\t  * @param {string=} tag The tag name of the Element.\n\t  * @param {?string=} key The key of the Element.\n\t  */\n\t  var assertKeyedTagMatches = function (node, tag, key) {\n\t    var nodeName = getData(node).nodeName;\n\t    if (nodeName !== tag) {\n\t      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Checks whether or not a given node matches the specified nodeName and key.\n\t *\n\t * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (node, nodeName, key) {\n\t  var data = getData(node);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return key == data.key && nodeName === data.nodeName;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t * @return {!Node} The matching node.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var currentNode = walker.currentNode;\n\t  var parent = walker.getCurrentParent();\n\t  var matchingNode;\n\t\n\t  // Check to see if we have a node to reuse\n\t  if (currentNode && matches(currentNode, nodeName, key)) {\n\t    matchingNode = currentNode;\n\t  } else {\n\t    var existingNode = getChild(parent, key);\n\t\n\t    // Check to see if the node has moved within the parent or if a new one\n\t    // should be created\n\t    if (existingNode) {\n\t      if (process.env.NODE_ENV !== 'production') {\n\t        assertKeyedTagMatches(existingNode, nodeName, key);\n\t      }\n\t\n\t      matchingNode = existingNode;\n\t    } else {\n\t      matchingNode = createNode(context.doc, nodeName, key, statics);\n\t\n\t      if (key) {\n\t        registerChild(parent, key, matchingNode);\n\t      }\n\t\n\t      context.markCreated(matchingNode);\n\t    }\n\t\n\t    // If the node has a key, remove it from the DOM to prevent a large number\n\t    // of re-orders in the case that it moved far or was completely removed.\n\t    // Since we hold on to a reference through the keyMap, we can always add it\n\t    // back.\n\t    if (currentNode && getData(currentNode).key) {\n\t      parent.replaceChild(matchingNode, currentNode);\n\t      getData(parent).keyMapValid = false;\n\t    } else {\n\t      parent.insertBefore(matchingNode, currentNode);\n\t    }\n\t\n\t    walker.currentNode = matchingNode;\n\t  }\n\t\n\t  return matchingNode;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t * @param {Node} node\n\t */\n\tvar clearUnvisitedDOM = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var lastVisitedChild = data.lastVisitedChild;\n\t  var child = node.lastChild;\n\t  var key;\n\t\n\t  data.lastVisitedChild = null;\n\t\n\t  if (child === lastVisitedChild && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n\t    return;\n\t  }\n\t\n\t  while (child !== lastVisitedChild) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  for (key in keyMap) {\n\t    child = keyMap[key];\n\t    if (!child.parentNode) {\n\t      context.markDeleted(child);\n\t      delete keyMap[key];\n\t    }\n\t  }\n\t\n\t  data.keyMapValid = true;\n\t};\n\t\n\t/**\n\t * Enters an Element, setting the current namespace for nested elements.\n\t * @param {Node} node\n\t */\n\tvar enterNode = function (node) {\n\t  var data = getData(node);\n\t  enterTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Exits an Element, unwinding the current namespace to the previous value.\n\t * @param {Node} node\n\t */\n\tvar exitNode = function (node) {\n\t  var data = getData(node);\n\t  exitTag(data.nodeName);\n\t};\n\t\n\t/**\n\t * Marks node's parent as having visited node.\n\t * @param {Node} node\n\t */\n\tvar markVisited = function (node) {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  var parent = walker.getCurrentParent();\n\t  var data = getData(parent);\n\t  data.lastVisitedChild = node;\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar firstChild = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  enterNode(walker.currentNode);\n\t  walker.firstChild();\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextSibling = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  markVisited(walker.currentNode);\n\t  walker.nextSibling();\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar parentNode = function () {\n\t  var context = getContext();\n\t  var walker = context.walker;\n\t  walker.parentNode();\n\t  exitNode(walker.currentNode);\n\t};\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  var assertNoUnclosedTags = function (root) {\n\t    var openElement = getContext().walker.getCurrentParent();\n\t    if (!openElement) {\n\t      return;\n\t    }\n\t\n\t    var openTags = [];\n\t    while (openElement && openElement !== root) {\n\t      openTags.push(openElement.nodeName.toLowerCase());\n\t      openElement = openElement.parentNode;\n\t    }\n\t\n\t    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n\t  };\n\t}\n\t\n\t/**\n\t * Patches the document starting at el with the provided function. This function\n\t * may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\texports.patch = function (node, fn, data) {\n\t  enterContext(node);\n\t\n\t  firstChild();\n\t  fn(data);\n\t  parentNode();\n\t  clearUnvisitedDOM(node);\n\t\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNoUnclosedTags(node);\n\t  }\n\t\n\t  getContext().notifyChanges();\n\t  restoreContext();\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  /**\n\t   * Keeps track whether or not we are in an attributes declaration (after\n\t   * elementOpenStart, but before elementOpenEnd).\n\t   * @type {boolean}\n\t   */\n\t  var inAttributes = false;\n\t\n\t  /** Makes sure that the caller is not where attributes are expected. */\n\t  var assertNotInAttributes = function () {\n\t    if (inAttributes) {\n\t      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n\t    }\n\t  };\n\t\n\t  /** Makes sure that the caller is where attributes are expected. */\n\t  var assertInAttributes = function () {\n\t    if (!inAttributes) {\n\t      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that placeholders have a key specified. Otherwise, conditional\n\t   * placeholders and conditional elements next to placeholders will cause\n\t   * placeholder elements to be re-used as non-placeholders and vice versa.\n\t   * @param {string} key\n\t   */\n\t  var assertPlaceholderKeySpecified = function (key) {\n\t    if (!key) {\n\t      throw new Error('Placeholder elements must have a key specified.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Makes sure that tags are correctly nested.\n\t   * @param {string} tag\n\t   */\n\t  var assertCloseMatchesOpenTag = function (tag) {\n\t    var context = getContext();\n\t    var walker = context.walker;\n\t    var closingNode = walker.getCurrentParent();\n\t    var data = getData(closingNode);\n\t\n\t    if (tag !== data.nodeName) {\n\t      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n\t    }\n\t  };\n\t\n\t  /** Updates the state to being in an attribute declaration. */\n\t  var setInAttributes = function () {\n\t    inAttributes = true;\n\t  };\n\t\n\t  /** Updates the state to not being in an attribute declaration. */\n\t  var setNotInAttributes = function () {\n\t    inAttributes = false;\n\t  };\n\t}\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpen = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    var attr,\n\t        newAttrs = data.newAttrs;\n\t\n\t    for (attr in newAttrs) {\n\t      newAttrs[attr] = undefined;\n\t    }\n\t\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (attr in newAttrs) {\n\t      updateAttribute(node, attr, newAttrs[attr]);\n\t    }\n\t  }\n\t\n\t  firstChild();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\texports.elementOpenStart = function (tag, key, statics) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    setInAttributes();\n\t  }\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\texports.attr = function (name, value) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t  }\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementOpenEnd = function () {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes();\n\t    setNotInAttributes();\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementClose = function (tag) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t    assertCloseMatchesOpenTag(tag);\n\t  }\n\t\n\t  parentNode();\n\t\n\t  var node = /** @type {!Element} */getContext().walker.currentNode;\n\t\n\t  clearUnvisitedDOM(node);\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementVoid = function (tag, key, statics, var_args) {\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\texports.elementPlaceholder = function (tag, key, statics, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertPlaceholderKeySpecified(key);\n\t  }\n\t\n\t  var node = exports.elementOpen.apply(null, arguments);\n\t  updateAttribute(node, exports.symbols.placeholder, true);\n\t  exports.elementClose.apply(null, arguments);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} var_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\texports.text = function (value, var_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      formatted = arguments[i](formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  nextSibling();\n\t  return node;\n\t};\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b241b280923dbda71c9e\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar createRenderer = require('./render');\n\nvar render = function(node, data) {\n  var _render = createRenderer(node);\n  _render(data);\n  return _render;\n};\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: createRenderer,\n  render: render\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*! (C) WebReflection Mit Style License */\n(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/document-register-element/build/document-register-element.js\n ** module id = 1\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render');\n\nvar RENDER = '__render';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        console.log('attached!', this);\n        this.update();\n      }},\n\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      render: {value: function(data) {\n        if (!arguments.length) data = this.data;\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      invalidate: {value: function() {\n        this[RENDER] = null;\n        this.render();\n      }},\n\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function property(read, write, value) {\n  return {\n    enumerable: false,\n\n    get: function() {\n      return read ? read.call(this, value) : value;\n    },\n\n    set: function(v) {\n      if (v !== value) {\n        var previous = value;\n        return value = write.call(this, v, previous);\n      }\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 3\n ** module chunks = 0\n **/","var arrow = require('./arrow');\n\nvar evaluate = function(expression, context) {\n  var fn = evaluator(expression);\n  return fn.call(this, context);\n};\n\nvar evaluator = function(expression) {\n  if (arrow.is(expression)) {\n    return parseArrow(expression);\n  }\n\n  var symbol = 'd' + Date.now();\n  // '.' is just the identity function\n  if (expression === '.') {\n    return function identity(d) { return d; };\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    'with (', symbol, ' || {}) {',\n    '  return ', expression, ';',\n    '} ',\n    '} catch (error) { }'\n  ].join(''));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator,\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 4\n ** module chunks = 0\n **/","var ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = match[4] || match[5];\n  return new Function(args, 'return (' + body + ')');\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 5\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar incremental = require('incremental-dom');\nvar xp = require('./evaluate');\n\nvar T_NAMESPACE = 't-';\nvar T_IF = T_NAMESPACE + 'if';\nvar T_EACH = T_NAMESPACE + 'each';\nvar T_TEXT = T_NAMESPACE + 'text';\nvar T_FOREACH = T_NAMESPACE + 'foreach';\n\nvar CONTROL_ATTRS = [T_IF, T_EACH, T_FOREACH, T_TEXT];\n\nvar VOID_ELEMENTS = [\n  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',\n  'input', 'keygen', 'link', 'meta', 'param', 'source', 'track',\n  'wbr'\n];\n\nmodule.exports = createRenderFunction;\n\nfunction createRenderFunction(root) {\n  var render = createRenderer(root);\n  return function _render(data) {\n    // console.log('rendering with data:', data);\n    return incremental.patch(root, render.bind(this, data));\n  };\n}\n\nfunction createRenderer(root) {\n  var calls = [];\n  for (\n    var child = root.firstChild; child;\n    child = child.nextSibling\n  ) {\n    switch (child.nodeType) {\n      case Node.TEXT_NODE:\n        calls.push(createTextRenderer(child));\n        break;\n      case Node.ELEMENT_NODE:\n        calls.push(createElementRenderer(child));\n        break;\n    }\n  }\n  return function patch(data) {\n    // console.log('patching:', root, 'with', data);\n    calls.forEach(function(fn) {\n      fn(data);\n    });\n  };\n}\n\nfunction createTextRenderer(node) {\n  // TODO: expand {{ expressions }} ?\n  return function(data) {\n    incremental.text(node.nodeValue);\n  };\n}\n\nfunction createElementRenderer(node) {\n  var name = node.nodeName.toLowerCase();\n\n  var isVoid = isElementVoid(name);\n  var attrMap = getAttributeMap(node);\n\n  var condition = node.hasAttribute(T_IF)\n    ? xp.evaluator(node.getAttribute(T_IF))\n    : null;\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  var textExpression = node.getAttribute(T_TEXT);\n  if (textExpression) {\n    var getText = xp.evaluator(textExpression);\n    renderChildren = function(data) {\n      var value = getText(data);\n      if (value !== null && value !== undefined) {\n        incremental.text(String(value));\n      }\n    };\n  } else {\n    renderChildren = createRenderer(node);\n  }\n\n  var render = function(data) {\n    // console.log('rendering', node, 'with data:', data);\n    if (condition && !condition(data)) {\n      return false;\n    }\n\n    var attrs = interpolateAttributes(attrMap, data);\n    if (isVoid) {\n      incremental.elementVoid(name, '', attrs);\n    } else {\n      incremental.elementOpen(name, '', attrs);\n      renderChildren(data);\n      incremental.elementClose(name);\n    }\n  };\n\n  var eachExpression = node.getAttribute(T_EACH);\n  var forEachExpression = node.getAttribute(T_FOREACH);\n\n  // <ul><li t-each=\"items\">{{ . }}</li></ul>\n  if (eachExpression) {\n    // console.info('render each:', node, eachExpression);\n    render = renderEach(eachExpression, render);\n  // <ul t-foreach=\"items\"><li>{{ . }}</li></ul>\n  } else if (forEachExpression) {\n    // console.info('render foreach:', node, forEachExpression);\n    renderChildren = renderEach(forEachExpression, renderChildren);\n  } else {\n    // console.info('render once:', node);\n  }\n\n  return render;\n}\n\nfunction renderEach(expression, render) {\n  return function(data) {\n    var values = xp.evaluate(expression, data);\n    forEach(values, render);\n  };\n}\n\nfunction getAttributeMap(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = String(attr.name);\n    if (CONTROL_ATTRS.indexOf(name) > -1) {\n      // console.info('skipping control attribute', name, 'for', node);\n      continue;\n    } else if (name.indexOf(T_NAMESPACE) === 0) {\n      var getter = xp.evaluator(attr.value);\n      map[name.substr(T_NAMESPACE.length)] = getter;\n    } else {\n      map[name] = attr.value;\n    }\n  }\n  return map;\n}\n\nfunction interpolateAttributes(attrMap, data) {\n  var attrs = [];\n  for (var key in attrMap) {\n    var value = attrMap[key];\n    attrs.push(key, (typeof value === 'function')\n      ? value(data, key)\n      : String(value));\n  }\n  return attrs;\n}\n\nfunction isElementVoid(name) {\n  return VOID_ELEMENTS.indexOf(name) > -1;\n}\n\nfunction forEach(data, fn) {\n  return data.forEach(fn, this);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 6\n ** module chunks = 0\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     walker should start traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /**\n   * @const {!Element|!DocumentFragment}\n   */\n  this.root = node;\n\n  /**\n   * @type {?Node}\n   */\n  this.currentNode = node;\n}\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function () {\n  return this.stack_[this.stack_.length - 1];\n};\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function () {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function () {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function () {\n  this.currentNode = this.stack_.pop();\n};\n\n/**\n * Keeps track of the state of a patch.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     is for.\n * @param {?Context} prevContext The previous context.\n * @constructor\n */\nfunction Context(node, prevContext) {\n  /**\n   * @const {TreeWalker}\n   */\n  this.walker = new TreeWalker(node);\n\n  /**\n   * @const {Document}\n   */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @private\n   * @const {!Array<(string|undefined)>}\n   */\n  this.nsStack_ = [undefined];\n\n  /**\n   * @const {?Context}\n   */\n  this.prevContext = prevContext;\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n/**\n * @return {(string|undefined)} The current namespace to create Elements in.\n */\nContext.prototype.getCurrentNamespace = function () {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n/**\n * @param {string=} namespace The namespace to enter.\n */\nContext.prototype.enterNamespace = function (namespace) {\n  this.nsStack_.push(namespace);\n};\n\n/**\n * Exits the current namespace\n */\nContext.prototype.exitNamespace = function () {\n  this.nsStack_.pop();\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * The current context.\n * @type {?Context}\n */\nvar context;\n\n/**\n * Enters a new patch context.\n * @param {!Element|!DocumentFragment} node\n */\nvar enterContext = function (node) {\n  context = new Context(node, context);\n};\n\n/**\n * Restores the previous patch context.\n */\nvar restoreContext = function () {\n  context = context.prevContext;\n};\n\n/**\n * Gets the current patch context.\n * @return {?Context}\n */\nvar getContext = function () {\n  return context;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * @type {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {string|Object<string,string>} style The style to set. Either a\n *     string of css or an object containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n\n    for (var prop in style) {\n      if (has(style, prop)) {\n        elStyle[prop] = style[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function () {};\n\nexports.attributes['style'] = applyStyle;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function (tag) {\n  if (tag === 'svg') {\n    getContext().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getContext().enterNamespace(undefined);\n  }\n};\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function (tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getContext().exitNamespace();\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {(string|undefined)} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getContext().getCurrentNamespace();\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function (doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Node} parent\n * @param {?string=} key\n * @return {?Element} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return (/** @type {?Element} */key && getKeyMap(parent)[key]\n  );\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!Element} node The node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function (node, tag, key) {\n    var nodeName = getData(node).nodeName;\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n    }\n  };\n}\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key && nodeName === data.nodeName;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  var context = getContext();\n  var walker = context.walker;\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(existingNode, nodeName, key);\n      }\n\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(context.doc, nodeName, key, statics);\n\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n\n      context.markCreated(matchingNode);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      parent.replaceChild(matchingNode, currentNode);\n      getData(parent).keyMapValid = false;\n    } else {\n      parent.insertBefore(matchingNode, currentNode);\n    }\n\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {Node} node\n */\nvar clearUnvisitedDOM = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var lastVisitedChild = data.lastVisitedChild;\n  var child = node.lastChild;\n  var key;\n\n  data.lastVisitedChild = null;\n\n  if (child === lastVisitedChild && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n    return;\n  }\n\n  while (child !== lastVisitedChild) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  for (key in keyMap) {\n    child = keyMap[key];\n    if (!child.parentNode) {\n      context.markDeleted(child);\n      delete keyMap[key];\n    }\n  }\n\n  data.keyMapValid = true;\n};\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {Node} node\n */\nvar enterNode = function (node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {Node} node\n */\nvar exitNode = function (node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n/**\n * Marks node's parent as having visited node.\n * @param {Node} node\n */\nvar markVisited = function (node) {\n  var context = getContext();\n  var walker = context.walker;\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function () {\n  var context = getContext();\n  var walker = context.walker;\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function () {\n  var context = getContext();\n  var walker = context.walker;\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function () {\n  var context = getContext();\n  var walker = context.walker;\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function (root) {\n    var openElement = getContext().walker.getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n  };\n}\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function (node, fn, data) {\n  enterContext(node);\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  getContext().notifyChanges();\n  restoreContext();\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function () {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');\n    }\n  };\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function () {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');\n    }\n  };\n\n  /**\n   * Makes sure that placeholders have a key specified. Otherwise, conditional\n   * placeholders and conditional elements next to placeholders will cause\n   * placeholder elements to be re-used as non-placeholders and vice versa.\n   * @param {string} key\n   */\n  var assertPlaceholderKeySpecified = function (key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function (tag) {\n    var context = getContext();\n    var walker = context.walker;\n    var closingNode = walker.getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');\n    }\n  };\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function () {\n    inAttributes = true;\n  };\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function () {\n    inAttributes = false;\n  };\n}\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var attr,\n        newAttrs = data.newAttrs;\n\n    for (attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = /** @type {!Element} */getContext().walker.currentNode;\n\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function (tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  var node = exports.elementOpen.apply(null, arguments);\n  updateAttribute(node, exports.symbols.placeholder, true);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Text}*/alignWithDOM('#text', null);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n  return node;\n};\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/dist/incremental-dom-cjs.js\n ** module id = 7\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 8\n ** module chunks = 0\n **/"],"sourceRoot":""}
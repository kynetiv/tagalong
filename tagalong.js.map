{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap 087cb910d95cf533c9ef","webpack:///./src/main.js","webpack:///./~/document-register-element/build/document-register-element.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/functor.js","webpack:///./src/render.js","webpack:///./src/interpolate.js","webpack:///./src/h.js","webpack:///./src/ns.js","webpack:///./~/morphdom/lib/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Template","render","window","tagalong","createRenderer","create","e","t","n","r","rt","length","dt","it","nt","b","ot","st","j","querySelectorAll","w","getAttribute","nodeName","toUpperCase","S","y","v","d","ut","indexOf","at","currentTarget","attrChange","attrName","i","target","Q","attributeChangedCallback","a","prevValue","l","newValue","ft","X","push","lt","K","removeEventListener","h","detail","o","s","B","pt","ct","this","q","G","ht","D","et","observe","z","J","setAttribute","Z","addEventListener","createdCallback","created","F","E","contains","splice","tt","Y","Math","random","u","f","g","documentElement","x","prototype","T","hasOwnProperty","N","isPrototypeOf","C","defineProperty","k","getOwnPropertyDescriptor","L","getOwnPropertyNames","A","getPrototypeOf","O","setPrototypeOf","M","__proto__","_","vt","P","MutationObserver","WebKitMutationObserver","H","HTMLElement","Element","Node","nodeType","I","cloneNode","R","removeAttribute","U","createElement","attributes","characterData","attributeOldValue","W","V","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","$","value","CustomEvent","bubbles","dispatchEvent","hasAttribute","propertyName","name","className","type","addedNodes","removedNodes","attributeName","oldValue","childList","subtree","shift","apply","arguments","toLowerCase","innerHTMLHelper","Error","test","concat","document","Object","property","evaluate","RENDER","DATA_ATTR","registerElement","attachedCallback","console","log","update","attr","previous","expr","data","invalidate","read","write","enumerable","get","set","identity","arrow","functor","expression","fn","evaluator","String","trim","undefined","is","parse","symbol","match","Function","join","ARROW_PATTERN","isArrow","parseArrow","args","body","compileExpression","interpolate","isTemplate","compile","code","createTextRenderer","node","stringify","nodeValue","createElementRenderer","T_SKIP","noop","attrMap","getAttributeMap","condition","T_IF","xp","T_ELSE","ifSibling","getPreviousSibling","not","renderChildren","T_TEXT","childRenderers","map","childNodes","renderChild","renderNode","attrs","interpolateAttributes","children","eachExpression","T_EACH","forEachExpression","T_FOREACH","withExpression","T_WITH","T_AS","renderEach","renderWith","symbolSetter","values","forEach","ns","qualify","localName","T_NS","substr","CONTROL_ATTRS","qname","prefix","key","defined","selector","previousSibling","matches","iterate","result","INDEX","each","Array","isArray","split","context","morphdom","src","querySelector","dest","pattern","str","RegExp","template","that","replace","part","props","createDocumentFragment","namespaceURI","createElementNS","setProps","append","child","appendChild","createTextNode","el","prop","formatClassName","formatStyle","warn","setAttributeNS","obj","keys","reformatCamelCase","char","filter","prefixToURI","svg","xlink","xmlns","uriToPrefix","colon","empty","toElement","range","createRange","selectNode","fragment","createContextualFragment","innerHTML","morphAttrs","fromNode","toNode","attrValue","foundAttrs","specified","moveChildren","fromEl","toEl","curChild","firstChild","nextChild","nextSibling","defaultGetNodeKey","options","removeNodeHelper","nestedInSavedEl","getNodeKey","savedEls","onNodeDiscarded","walkDiscardedChildNodes","removeNode","parentNode","alreadyVisited","onBeforeNodeDiscarded","removeChild","morphEl","childrenOnly","toElKey","onBeforeElUpdated","onElUpdated","onBeforeElChildrenUpdated","tagName","curToNodeId","fromNextSibling","toNextSibling","savedEl","unmatchedEl","curToNodeChild","curFromNodeChild","outer","curFromNodeId","unmatchedEls","replaceChild","curFromNodeType","isCompatible","onBeforeNodeAdded","onNodeAdded","movedEls","specialElHandler","specialElHandlers","toNodeHtml","onBeforeMorphEl","onBeforeMorphElChildren","morphedNode","morphedNodeType","toNodeType","handleMovedEl","handleMovedElsLoop","movedElsTemp","savedElId","testEl","getAttributeNode","OPTION","selected","INPUT","checked","TEXTAREA"],"mappings":"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","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t\n\tvar Template = __webpack_require__(2);\n\tvar render = __webpack_require__(7);\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: render.create,\n\t  render: render.render\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*! (C) WebReflection Mit Style License */\n\t(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(3);\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar createRenderer = __webpack_require__(7).create;\n\t\n\tvar RENDER = '__render';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        console.log('attached!', this);\n\t        this.update();\n\t      }},\n\t\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      render: {value: function(data) {\n\t        if (!arguments.length) data = this.data;\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t        this.render();\n\t      }},\n\t\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, value) {\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      return read ? read.call(this, value) : value;\n\t    },\n\t\n\t    set: function(v) {\n\t      if (v !== value) {\n\t        var previous = value;\n\t        return value = write.call(this, v, previous);\n\t      }\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrow = __webpack_require__(5);\n\tvar functor = __webpack_require__(6);\n\t\n\tvar evaluate = function(expression, data) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, data);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (typeof expression !== 'string') {\n\t    expression = String(expression);\n\t  }\n\t\n\t  if (!expression.trim()) {\n\t    return functor(undefined);\n\t  }\n\t\n\t  if (arrow.is(expression)) {\n\t    return arrow.parse(expression);\n\t  }\n\t\n\t  var symbol = 'd';\n\t  // '.' is just the identity function\n\t  if (expression.match(/^\\s*\\.\\s*$/)) {\n\t    return identity;\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    '  with (this) {',\n\t    '    with (', symbol, ') {',\n\t    '      return (', expression, ');',\n\t    '    } ',\n\t    '  } ',\n\t    '} catch (error) { }'\n\t  ].join('\\n'));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator,\n\t};\n\t\n\tfunction identity(d) {\n\t  return d;\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = match[4] || match[5];\n\t  return new Function(args, [\n\t    'try {',\n\t    '  with (this) {',\n\t    '    return (', body, ');',\n\t    '  }',\n\t    '} catch (error) { }'\n\t  ].join('\\n'));\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function functor(x) {\n\t  return function f() {\n\t    return x;\n\t  }\n\t};\n\t\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar functor = __webpack_require__(6);\n\tvar xp = __webpack_require__(4);\n\tvar interpolate = __webpack_require__(8);\n\tvar h = __webpack_require__(9);\n\t\n\tvar morphdom = __webpack_require__(11);\n\t\n\tvar ns = __webpack_require__(10);\n\t\n\t// our attribute namespace\n\tvar T_NS = 't-';\n\t\n\tvar T_AS = T_NS + 'as';\n\tvar T_EACH = T_NS + 'each';\n\tvar T_ELSE = T_NS + 'else';\n\tvar T_FOREACH = T_NS + 'foreach';\n\tvar T_IF = T_NS + 'if';\n\tvar T_SKIP = T_NS + 'skip';\n\tvar T_TEXT = T_NS + 'text';\n\tvar T_WITH = T_NS + 'with';\n\t\n\tvar CONTROL_ATTRS = [\n\t  'as',\n\t  'each',\n\t  'else',\n\t  'foreach',\n\t  'if',\n\t  'skip',\n\t  'text',\n\t  'with'\n\t];\n\t\n\tvar createRenderer = function(src, context) {\n\t  if (typeof src === 'string') {\n\t    var selector = src;\n\t    src = document.querySelector(src);\n\t    if (!src) {\n\t      throw new Error('no element found with selector: \"' + selector + '\"');\n\t    }\n\t  }\n\t\n\t  var render = compile(src);\n\t  return function(node, data) {\n\t    if (arguments.length < 2) {\n\t      data = node;\n\t    }\n\t    if ((!node && data) || node === data) {\n\t      node = src;\n\t    }\n\t    var dest = render.call(context || this, data);\n\t    // console.log('morphing:', src.outerHTML, '->', dest.outerHTML);\n\t    return morphdom(src, dest);\n\t  }\n\t};\n\t\n\tvar render = function(src, data, context) {\n\t  var render = createRenderer(src, context);\n\t  if (data) {\n\t    render(src, data);\n\t  }\n\t  return render;\n\t};\n\t\n\tvar compile = function(node) {\n\t  switch (node.nodeType) {\n\t    case 1: // Node.ELEMENT_NODE\n\t      return createElementRenderer(node);\n\t    case 3: // Node.TEXT_NODE\n\t      return createTextRenderer(node);\n\t\n\t    // TODO: support document fragments?\n\t    // this would need support in h()\n\t\n\t    default:\n\t      throw new Error('no renderer for node type: ' + node.nodeType);\n\t  }\n\t};\n\t\n\tmodule.exports.render = render;\n\tmodule.exports.createRenderer = createRenderer;\n\tmodule.exports.compile = compile;\n\t\n\tfunction compileExpression(expr) {\n\t  return interpolate.isTemplate(expr)\n\t    ? interpolate.compile(expr)\n\t    : code.evaluator(expr);\n\t}\n\t\n\tfunction createTextRenderer(node) {\n\t  return stringify(interpolate.compile(node.nodeValue));\n\t}\n\t\n\tfunction createElementRenderer(node) {\n\t  // this element will never be rendered if it has a truthy t-skip attribute\n\t  if (node.hasAttribute(T_SKIP)) {\n\t    return noop;\n\t  }\n\t\n\t  var name = node.nodeName.toLowerCase();\n\t  var attrMap = getAttributeMap(node);\n\t\n\t  var condition = node.hasAttribute(T_IF)\n\t    ? xp.evaluator(node.getAttribute(T_IF))\n\t    : undefined;\n\t\n\t  if (node.hasAttribute(T_ELSE)) {\n\t    if (condition) {\n\t      throw new Error('element has both t-if and t-else attributes');\n\t    }\n\t    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n\t    if (!ifSibling) {\n\t      throw new Error('element with t-else has no matching t-if sibling');\n\t    }\n\t    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n\t  }\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  if (node.hasAttribute(T_TEXT)) {\n\t    renderChildren = stringify(\n\t      compileExpression(node.getAttribute(T_TEXT))\n\t    );\n\t  } else {\n\t    var childRenderers = [].map.call(node.childNodes, compile);\n\t    renderChildren = function(data) {\n\t      return childRenderers.map(function(renderChild) {\n\t        return renderChild.call(this, data);\n\t      }, this);\n\t    };\n\t  }\n\t\n\t  var renderNode = function(data) {\n\t    // console.log('rendering', node, 'with data:', data);\n\t    if (condition && !condition.call(this, data)) {\n\t      return undefined;\n\t    }\n\t\n\t    var attrs = interpolateAttributes.call(this, attrMap, data);\n\t    var children = renderChildren.call(this, data);\n\t    return h(name, attrs, children);\n\t  };\n\t\n\t  var eachExpression = node.getAttribute(T_EACH);\n\t  var forEachExpression = node.getAttribute(T_FOREACH);\n\t  var withExpression = node.getAttribute(T_WITH);\n\t\n\t  var symbol = node.getAttribute(T_AS);\n\t\n\t  if (eachExpression) {\n\t    renderNode = renderEach(eachExpression, renderNode, symbol);\n\t  } else if (forEachExpression) {\n\t    renderChildren = renderEach(forEachExpression, renderChildren, symbol);\n\t  } else if (withExpression) {\n\t    renderNode = renderWith(withExpression, renderNode, symbol);\n\t  } else if (symbol) {\n\t    renderNode = symbolSetter(symbol, renderNode);\n\t  }\n\t\n\t  return renderNode;\n\t}\n\t\n\tfunction renderEach(expression, render, symbol) {\n\t  var expr = xp.evaluator(expression);\n\t  return function(data) {\n\t    var values = expr.call(this, data);\n\t    return forEach.call(this, values, render, symbol);\n\t  };\n\t}\n\t\n\tfunction renderWith(expression, render, symbol) {\n\t  var expr = xp.evaluator(expression);\n\t  render = symbolSetter(symbol, render);\n\t  return function(data) {\n\t    data = expr.call(this, data);\n\t    return render.call(this, data);\n\t  };\n\t}\n\t\n\tfunction getAttributeMap(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = ns.qualify(attr.name);\n\t    var localName = name.localName;\n\t    var value = attr.value;\n\t    if (localName.indexOf(T_NS) === 0) {\n\t      localName = localName.substr(T_NS.length);\n\t      if (CONTROL_ATTRS.indexOf(localName) > -1) {\n\t        continue;\n\t      }\n\t      value = compileExpression(value);\n\t    }\n\t    var qname = name.prefix\n\t      ? name.prefix + ':' + localName\n\t      : localName;\n\t    map[qname] = value;\n\t  }\n\t  return map;\n\t}\n\t\n\tfunction interpolateAttributes(attrMap, data) {\n\t  var attrs = {};\n\t  for (var key in attrMap) {\n\t    var value = attrMap[key];\n\t    // only apply functions for attrs that aren't event handlers\n\t    if (typeof value === 'function' && key.indexOf('on') !== 0) {\n\t      value = value.call(this, data, key);\n\t    }\n\t    if (defined(value)) {\n\t      attrs[key] = value;\n\t    }\n\t  }\n\t  return attrs;\n\t}\n\t\n\tfunction getPreviousSibling(node, selector) {\n\t  while (node = node.previousSibling) {\n\t    if (!node) break;\n\t    // FIXME this needs a vendor prefix in IE 9+\n\t    // <http://caniuse.com/#search=matches>\n\t    if (node.matches(selector)) return node;\n\t  }\n\t  throw new Error('no previous sibling found matching: ' + selector);\n\t}\n\t\n\tfunction isElementVoid(name) {\n\t  return VOID_ELEMENTS.indexOf(name) > -1;\n\t}\n\t\n\tfunction forEach(data, fn, symbol) {\n\t  var previous;\n\t  var iterate = symbol\n\t    ? symbolSetter(symbol, fn)\n\t    : fn;\n\t\n\t  var result = [];\n\t  var INDEX = '$i';\n\t  var each = function(d, i) {\n\t    this[INDEX] = i;\n\t    result.push(iterate.call(this, d));\n\t    delete this[INDEX];\n\t  };\n\t\n\t  if (typeof data === 'object') {\n\t    if (Array.isArray(data)) {\n\t      data.forEach(each, this);\n\t    } else {\n\t      var i = 0;\n\t      for (var key in data) {\n\t        if (data.hasOwnProperty(key)) {\n\t          each.call(this, {key: key, value: data[key]}, i++);\n\t        }\n\t      }\n\t    }\n\t  } else if (typeof data === 'string') {\n\t    data.split('').forEach(each, this);\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tfunction symbolSetter(symbol, fn) {\n\t  return function(data) {\n\t    var previous = set(this, symbol, data);\n\t    var result = fn.call(this, data);\n\t    set(this, symbol, previous);\n\t    return result;\n\t  };\n\t}\n\t\n\tfunction defined(value) {\n\t  return value !== null && value !== undefined;\n\t}\n\t\n\tfunction not(fn) {\n\t  return function() {\n\t    return !fn.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction set(context, symbol, value) {\n\t  var previous = context[symbol];\n\t  if (value === undefined) {\n\t    delete context[symbol];\n\t  } else {\n\t    context[symbol] = value;\n\t  }\n\t  return previous;\n\t}\n\t\n\tfunction stringify(fn) {\n\t  return function() {\n\t    var value = fn.apply(this, arguments);\n\t    return defined(value) ? String(value) : '';\n\t  };\n\t}\n\t\n\tfunction noop() {\n\t}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar functor = __webpack_require__(6);\n\t\n\tvar pattern = /{{\\s*([^}]+)\\s*}}/g;\n\t\n\tvar isTemplate = function(str) {\n\t  return new RegExp(pattern).test(str);\n\t};\n\t\n\tvar compile = function(template) {\n\t  if (typeof template !== 'string') {\n\t    throw new Error('interpolate.compile() expected a string;' +\n\t                    'got ' + (typeof template));\n\t  }\n\t\n\t  if (!isTemplate(template)) {\n\t    return functor(template);\n\t  }\n\t\n\t  return function(data) {\n\t    var that = this;\n\t    return template.replace(pattern, function(_, part) {\n\t      return evaluate.call(that, part, data);\n\t    });\n\t  };\n\t};\n\t\n\tvar interpolate = function interpolate(str, data) {\n\t  return compile(str).call(this, data);\n\t};\n\t\n\tmodule.exports = interpolate;\n\t\n\tmodule.exports.isTemplate = isTemplate;\n\t\n\tmodule.exports.compile = compile;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ns = __webpack_require__(10);\n\t\n\tmodule.exports = function(name, props, children) {\n\t  var node;\n\t  if (Array.isArray(name)) {\n\t    node = document.createDocumentFragment();\n\t  } else {\n\t    name = ns.qualify(name);\n\t    node = name.namespaceURI\n\t      ? document.createElementNS(name.namespaceURI, name.localName)\n\t      : document.createElement(name.localName);\n\t  }\n\t\n\t  if (Array.isArray(props) || typeof props === 'string') {\n\t    children = props;\n\t  } else if (typeof props === 'object') {\n\t    setProps(node, props);\n\t  }\n\t\n\t  var append = function(child) {\n\t    if (Array.isArray(child)) {\n\t      child.forEach(append);\n\t    } else if (typeof child === 'object') {\n\t      node.appendChild(child);\n\t    } else if (typeof child === 'string') {\n\t      node.appendChild(document.createTextNode(child));\n\t    }\n\t  };\n\t\n\t  if (typeof children === 'object' || typeof children === 'string') {\n\t    append(children);\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\tvar setProps = function(el, props) {\n\t  for (var prop in props) {\n\t    var value = props[prop];\n\t    if (value === null || value === undefined || typeof value === 'function') {\n\t      // XXX: don't add null, undefined, or function values\n\t      continue;\n\t    } else if (typeof value === 'object') {\n\t      switch (prop) {\n\t        case 'class':\n\t          value = formatClassName(value);\n\t          break;\n\t\n\t        case 'style':\n\t          value = formatStyle(value);\n\t          break;\n\t\n\t        default:\n\t          console.warn('unrecognized object prop:', prop, value);\n\t          continue;\n\t      }\n\t    }\n\t\n\t    var name = ns.qualify(prop);\n\t    if (name.namespaceURI) {\n\t      el.setAttributeNS(name.namespaceURI, name.name, value);\n\t    } else {\n\t      el.setAttribute(name.localName, value);\n\t    }\n\t  }\n\t};\n\t\n\tvar formatStyle = function(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join('; ');\n\t  }\n\t  return Object.keys(obj)\n\t    .map(function(key) {\n\t      return [\n\t        reformatCamelCase(key),\n\t        ': ',\n\t        obj[key],\n\t        ';'\n\t      ].join('');\n\t    })\n\t    .join(' ');\n\t};\n\t\n\tvar reformatCamelCase = function(str) {\n\t  return str.replace(/[A-Z]/g, function(char) {\n\t    return '-' + char.toLowerCase();\n\t  });\n\t};\n\t\n\tvar formatClassName = function(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t  return Object.keys(obj).filter(function(key) {\n\t    return !!obj[key];\n\t  }).join(' ');\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar prefixToURI = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  xlink: 'http://www.w3.org/TR/xlink/',\n\t  xmlns: 'http://www.w3.org/2000/xmlns/'\n\t};\n\t\n\tvar uriToPrefix = {};\n\tObject.keys(prefixToURI).forEach(function(prefix) {\n\t  uriToPrefix[prefixToURI[prefix]] = prefix;\n\t});\n\t\n\tvar qualify = function(qname) {\n\t  var prefix;\n\t  var localName = qname;\n\t  var colon = qname.indexOf(':');\n\t  if (colon > -1) {\n\t    prefix = qname.substr(0, colon);\n\t    localName = qname.substr(colon + 1);\n\t  }\n\t  return {\n\t    name: qname,\n\t    localName: localName,\n\t    prefix: prefix,\n\t    namespaceURI: prefixToURI[prefix]\n\t  };\n\t};\n\t\n\tmodule.exports = {\n\t  prefixToURI: prefixToURI,\n\t  uriToPrefix: uriToPrefix,\n\t  qualify: qualify\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t// Create a range object for efficently rendering strings to elements.\n\tvar range;\n\t\n\tvar testEl = typeof document !== 'undefined' ? document.body || document.createElement('div') : {};\n\t\n\t// Fixes https://github.com/patrick-steele-idem/morphdom/issues/32 (IE7+ support)\n\t// <=IE7 does not support el.hasAttribute(name)\n\tvar hasAttribute;\n\tif (testEl.hasAttribute) {\n\t    hasAttribute = function hasAttribute(el, name) {\n\t        return el.hasAttribute(name);\n\t    };\n\t} else {\n\t    hasAttribute = function hasAttribute(el, name) {\n\t        return el.getAttributeNode(name);\n\t    };\n\t}\n\t\n\tfunction empty(o) {\n\t    for (var k in o) {\n\t        if (o.hasOwnProperty(k)) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    return true;\n\t}\n\tfunction toElement(str) {\n\t    if (!range && document.createRange) {\n\t        range = document.createRange();\n\t        range.selectNode(document.body);\n\t    }\n\t\n\t    var fragment;\n\t    if (range && range.createContextualFragment) {\n\t        fragment = range.createContextualFragment(str);\n\t    } else {\n\t        fragment = document.createElement('body');\n\t        fragment.innerHTML = str;\n\t    }\n\t    return fragment.childNodes[0];\n\t}\n\t\n\tvar specialElHandlers = {\n\t    /**\n\t     * Needed for IE. Apparently IE doesn't think\n\t     * that \"selected\" is an attribute when reading\n\t     * over the attributes using selectEl.attributes\n\t     */\n\t    OPTION: function(fromEl, toEl) {\n\t        if ((fromEl.selected = toEl.selected)) {\n\t            fromEl.setAttribute('selected', '');\n\t        } else {\n\t            fromEl.removeAttribute('selected', '');\n\t        }\n\t    },\n\t    /**\n\t     * The \"value\" attribute is special for the <input> element\n\t     * since it sets the initial value. Changing the \"value\"\n\t     * attribute without changing the \"value\" property will have\n\t     * no effect since it is only used to the set the initial value.\n\t     * Similar for the \"checked\" attribute.\n\t     */\n\t    INPUT: function(fromEl, toEl) {\n\t        fromEl.checked = toEl.checked;\n\t\n\t        if (fromEl.value != toEl.value) {\n\t            fromEl.value = toEl.value;\n\t        }\n\t\n\t        if (!hasAttribute(toEl, 'checked')) {\n\t            fromEl.removeAttribute('checked');\n\t        }\n\t\n\t        if (!hasAttribute(toEl, 'value')) {\n\t            fromEl.removeAttribute('value');\n\t        }\n\t    },\n\t\n\t    TEXTAREA: function(fromEl, toEl) {\n\t        var newValue = toEl.value;\n\t        if (fromEl.value != newValue) {\n\t            fromEl.value = newValue;\n\t        }\n\t\n\t        if (fromEl.firstChild) {\n\t            fromEl.firstChild.nodeValue = newValue;\n\t        }\n\t    }\n\t};\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * Loop over all of the attributes on the target node and make sure the\n\t * original DOM node has the same attributes. If an attribute\n\t * found on the original node is not on the new node then remove it from\n\t * the original node\n\t * @param  {HTMLElement} fromNode\n\t * @param  {HTMLElement} toNode\n\t */\n\tfunction morphAttrs(fromNode, toNode) {\n\t    var attrs = toNode.attributes;\n\t    var i;\n\t    var attr;\n\t    var attrName;\n\t    var attrValue;\n\t    var foundAttrs = {};\n\t\n\t    for (i=attrs.length-1; i>=0; i--) {\n\t        attr = attrs[i];\n\t        if (attr.specified !== false) {\n\t            attrName = attr.name;\n\t            attrValue = attr.value;\n\t            foundAttrs[attrName] = true;\n\t\n\t            if (fromNode.getAttribute(attrName) !== attrValue) {\n\t                fromNode.setAttribute(attrName, attrValue);\n\t            }\n\t        }\n\t    }\n\t\n\t    // Delete any extra attributes found on the original DOM element that weren't\n\t    // found on the target element.\n\t    attrs = fromNode.attributes;\n\t\n\t    for (i=attrs.length-1; i>=0; i--) {\n\t        attr = attrs[i];\n\t        if (attr.specified !== false) {\n\t            attrName = attr.name;\n\t            if (!foundAttrs.hasOwnProperty(attrName)) {\n\t                fromNode.removeAttribute(attrName);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * Copies the children of one DOM element to another DOM element\n\t */\n\tfunction moveChildren(fromEl, toEl) {\n\t    var curChild = fromEl.firstChild;\n\t    while(curChild) {\n\t        var nextChild = curChild.nextSibling;\n\t        toEl.appendChild(curChild);\n\t        curChild = nextChild;\n\t    }\n\t    return toEl;\n\t}\n\t\n\tfunction defaultGetNodeKey(node) {\n\t    return node.id;\n\t}\n\t\n\tfunction morphdom(fromNode, toNode, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t\n\t    if (typeof toNode === 'string') {\n\t        if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n\t            var toNodeHtml = toNode;\n\t            toNode = document.createElement('html');\n\t            toNode.innerHTML = toNodeHtml;\n\t        } else {\n\t            toNode = toElement(toNode);\n\t        }\n\t    }\n\t\n\t    var savedEls = {}; // Used to save off DOM elements with IDs\n\t    var unmatchedEls = {};\n\t    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n\t    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n\t    var onNodeAdded = options.onNodeAdded || noop;\n\t    var onBeforeElUpdated = options.onBeforeElUpdated || options.onBeforeMorphEl || noop;\n\t    var onElUpdated = options.onElUpdated || noop;\n\t    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n\t    var onNodeDiscarded = options.onNodeDiscarded || noop;\n\t    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || options.onBeforeMorphElChildren || noop;\n\t    var childrenOnly = options.childrenOnly === true;\n\t    var movedEls = [];\n\t\n\t    function removeNodeHelper(node, nestedInSavedEl) {\n\t        var id = getNodeKey(node);\n\t        // If the node has an ID then save it off since we will want\n\t        // to reuse it in case the target DOM tree has a DOM element\n\t        // with the same ID\n\t        if (id) {\n\t            savedEls[id] = node;\n\t        } else if (!nestedInSavedEl) {\n\t            // If we are not nested in a saved element then we know that this node has been\n\t            // completely discarded and will not exist in the final DOM.\n\t            onNodeDiscarded(node);\n\t        }\n\t\n\t        if (node.nodeType === 1) {\n\t            var curChild = node.firstChild;\n\t            while(curChild) {\n\t                removeNodeHelper(curChild, nestedInSavedEl || id);\n\t                curChild = curChild.nextSibling;\n\t            }\n\t        }\n\t    }\n\t\n\t    function walkDiscardedChildNodes(node) {\n\t        if (node.nodeType === 1) {\n\t            var curChild = node.firstChild;\n\t            while(curChild) {\n\t\n\t\n\t                if (!getNodeKey(curChild)) {\n\t                    // We only want to handle nodes that don't have an ID to avoid double\n\t                    // walking the same saved element.\n\t\n\t                    onNodeDiscarded(curChild);\n\t\n\t                    // Walk recursively\n\t                    walkDiscardedChildNodes(curChild);\n\t                }\n\t\n\t                curChild = curChild.nextSibling;\n\t            }\n\t        }\n\t    }\n\t\n\t    function removeNode(node, parentNode, alreadyVisited) {\n\t        if (onBeforeNodeDiscarded(node) === false) {\n\t            return;\n\t        }\n\t\n\t        parentNode.removeChild(node);\n\t        if (alreadyVisited) {\n\t            if (!getNodeKey(node)) {\n\t                onNodeDiscarded(node);\n\t                walkDiscardedChildNodes(node);\n\t            }\n\t        } else {\n\t            removeNodeHelper(node);\n\t        }\n\t    }\n\t\n\t    function morphEl(fromEl, toEl, alreadyVisited, childrenOnly) {\n\t        var toElKey = getNodeKey(toEl);\n\t        if (toElKey) {\n\t            // If an element with an ID is being morphed then it is will be in the final\n\t            // DOM so clear it out of the saved elements collection\n\t            delete savedEls[toElKey];\n\t        }\n\t\n\t        if (!childrenOnly) {\n\t            if (onBeforeElUpdated(fromEl, toEl) === false) {\n\t                return;\n\t            }\n\t\n\t            morphAttrs(fromEl, toEl);\n\t            onElUpdated(fromEl);\n\t\n\t            if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        if (fromEl.tagName != 'TEXTAREA') {\n\t            var curToNodeChild = toEl.firstChild;\n\t            var curFromNodeChild = fromEl.firstChild;\n\t            var curToNodeId;\n\t\n\t            var fromNextSibling;\n\t            var toNextSibling;\n\t            var savedEl;\n\t            var unmatchedEl;\n\t\n\t            outer: while(curToNodeChild) {\n\t                toNextSibling = curToNodeChild.nextSibling;\n\t                curToNodeId = getNodeKey(curToNodeChild);\n\t\n\t                while(curFromNodeChild) {\n\t                    var curFromNodeId = getNodeKey(curFromNodeChild);\n\t                    fromNextSibling = curFromNodeChild.nextSibling;\n\t\n\t                    if (!alreadyVisited) {\n\t                        if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {\n\t                            unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);\n\t                            morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);\n\t                            curFromNodeChild = fromNextSibling;\n\t                            continue;\n\t                        }\n\t                    }\n\t\n\t                    var curFromNodeType = curFromNodeChild.nodeType;\n\t\n\t                    if (curFromNodeType === curToNodeChild.nodeType) {\n\t                        var isCompatible = false;\n\t\n\t                        if (curFromNodeType === 1) { // Both nodes being compared are Element nodes\n\t                            if (curFromNodeChild.tagName === curToNodeChild.tagName) {\n\t                                // We have compatible DOM elements\n\t                                if (curFromNodeId || curToNodeId) {\n\t                                    // If either DOM element has an ID then we handle\n\t                                    // those differently since we want to match up\n\t                                    // by ID\n\t                                    if (curToNodeId === curFromNodeId) {\n\t                                        isCompatible = true;\n\t                                    }\n\t                                } else {\n\t                                    isCompatible = true;\n\t                                }\n\t                            }\n\t\n\t                            if (isCompatible) {\n\t                                // We found compatible DOM elements so transform the current \"from\" node\n\t                                // to match the current target DOM node.\n\t                                morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);\n\t                            }\n\t                        } else if (curFromNodeType === 3) { // Both nodes being compared are Text nodes\n\t                            isCompatible = true;\n\t                            // Simply update nodeValue on the original node to change the text value\n\t                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n\t                        }\n\t\n\t                        if (isCompatible) {\n\t                            curToNodeChild = toNextSibling;\n\t                            curFromNodeChild = fromNextSibling;\n\t                            continue outer;\n\t                        }\n\t                    }\n\t\n\t                    // No compatible match so remove the old node from the DOM and continue trying\n\t                    // to find a match in the original DOM\n\t                    removeNode(curFromNodeChild, fromEl, alreadyVisited);\n\t                    curFromNodeChild = fromNextSibling;\n\t                }\n\t\n\t                if (curToNodeId) {\n\t                    if ((savedEl = savedEls[curToNodeId])) {\n\t                        morphEl(savedEl, curToNodeChild, true);\n\t                        curToNodeChild = savedEl; // We want to append the saved element instead\n\t                    } else {\n\t                        // The current DOM element in the target tree has an ID\n\t                        // but we did not find a match in any of the corresponding\n\t                        // siblings. We just put the target element in the old DOM tree\n\t                        // but if we later find an element in the old DOM tree that has\n\t                        // a matching ID then we will replace the target element\n\t                        // with the corresponding old element and morph the old element\n\t                        unmatchedEls[curToNodeId] = curToNodeChild;\n\t                    }\n\t                }\n\t\n\t                // If we got this far then we did not find a candidate match for our \"to node\"\n\t                // and we exhausted all of the children \"from\" nodes. Therefore, we will just\n\t                // append the current \"to node\" to the end\n\t                if (onBeforeNodeAdded(curToNodeChild) !== false) {\n\t                    fromEl.appendChild(curToNodeChild);\n\t                    onNodeAdded(curToNodeChild);\n\t                }\n\t\n\t                if (curToNodeChild.nodeType === 1 && (curToNodeId || curToNodeChild.firstChild)) {\n\t                    // The element that was just added to the original DOM may have\n\t                    // some nested elements with a key/ID that needs to be matched up\n\t                    // with other elements. We'll add the element to a list so that we\n\t                    // can later process the nested elements if there are any unmatched\n\t                    // keyed elements that were discarded\n\t                    movedEls.push(curToNodeChild);\n\t                }\n\t\n\t                curToNodeChild = toNextSibling;\n\t                curFromNodeChild = fromNextSibling;\n\t            }\n\t\n\t            // We have processed all of the \"to nodes\". If curFromNodeChild is non-null then\n\t            // we still have some from nodes left over that need to be removed\n\t            while(curFromNodeChild) {\n\t                fromNextSibling = curFromNodeChild.nextSibling;\n\t                removeNode(curFromNodeChild, fromEl, alreadyVisited);\n\t                curFromNodeChild = fromNextSibling;\n\t            }\n\t        }\n\t\n\t        var specialElHandler = specialElHandlers[fromEl.tagName];\n\t        if (specialElHandler) {\n\t            specialElHandler(fromEl, toEl);\n\t        }\n\t    } // END: morphEl(...)\n\t\n\t    var morphedNode = fromNode;\n\t    var morphedNodeType = morphedNode.nodeType;\n\t    var toNodeType = toNode.nodeType;\n\t\n\t    if (!childrenOnly) {\n\t        // Handle the case where we are given two DOM nodes that are not\n\t        // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n\t        if (morphedNodeType === 1) {\n\t            if (toNodeType === 1) {\n\t                if (fromNode.tagName !== toNode.tagName) {\n\t                    onNodeDiscarded(fromNode);\n\t                    morphedNode = moveChildren(fromNode, document.createElement(toNode.tagName));\n\t                }\n\t            } else {\n\t                // Going from an element node to a text node\n\t                morphedNode = toNode;\n\t            }\n\t        } else if (morphedNodeType === 3) { // Text node\n\t            if (toNodeType === 3) {\n\t                morphedNode.nodeValue = toNode.nodeValue;\n\t                return morphedNode;\n\t            } else {\n\t                // Text node to something else\n\t                morphedNode = toNode;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (morphedNode === toNode) {\n\t        // The \"to node\" was not compatible with the \"from node\"\n\t        // so we had to toss out the \"from node\" and use the \"to node\"\n\t        onNodeDiscarded(fromNode);\n\t    } else {\n\t        morphEl(morphedNode, toNode, false, childrenOnly);\n\t\n\t        /**\n\t         * What we will do here is walk the tree for the DOM element\n\t         * that was moved from the target DOM tree to the original\n\t         * DOM tree and we will look for keyed elements that could\n\t         * be matched to keyed elements that were earlier discarded.\n\t         * If we find a match then we will move the saved element\n\t         * into the final DOM tree\n\t         */\n\t        var handleMovedEl = function(el) {\n\t            var curChild = el.firstChild;\n\t            while(curChild) {\n\t                var nextSibling = curChild.nextSibling;\n\t\n\t                var key = getNodeKey(curChild);\n\t                if (key) {\n\t                    var savedEl = savedEls[key];\n\t                    if (savedEl && (curChild.tagName === savedEl.tagName)) {\n\t                        curChild.parentNode.replaceChild(savedEl, curChild);\n\t                        morphEl(savedEl, curChild, true /* already visited the saved el tree */);\n\t                        curChild = nextSibling;\n\t                        if (empty(savedEls)) {\n\t                            return false;\n\t                        }\n\t                        continue;\n\t                    }\n\t                }\n\t\n\t                if (curChild.nodeType === 1) {\n\t                    handleMovedEl(curChild);\n\t                }\n\t\n\t                curChild = nextSibling;\n\t            }\n\t        };\n\t\n\t        // The loop below is used to possibly match up any discarded\n\t        // elements in the original DOM tree with elemenets from the\n\t        // target tree that were moved over without visiting their\n\t        // children\n\t        if (!empty(savedEls)) {\n\t            handleMovedElsLoop:\n\t            while (movedEls.length) {\n\t                var movedElsTemp = movedEls;\n\t                movedEls = [];\n\t                for (var i=0; i<movedElsTemp.length; i++) {\n\t                    if (handleMovedEl(movedElsTemp[i]) === false) {\n\t                        // There are no more unmatched elements so completely end\n\t                        // the loop\n\t                        break handleMovedElsLoop;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Fire the \"onNodeDiscarded\" event for any saved elements\n\t        // that never found a new home in the morphed DOM\n\t        for (var savedElId in savedEls) {\n\t            if (savedEls.hasOwnProperty(savedElId)) {\n\t                var savedEl = savedEls[savedElId];\n\t                onNodeDiscarded(savedEl);\n\t                walkDiscardedChildNodes(savedEl);\n\t            }\n\t        }\n\t    }\n\t\n\t    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n\t        // If we had to swap out the from node with a new node because the old\n\t        // node was not compatible with the target node then we need to\n\t        // replace the old DOM node in the original DOM tree. This is only\n\t        // possible if the original DOM node was part of a DOM tree which\n\t        // we know is the case if it has a parent node.\n\t        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n\t    }\n\t\n\t    return morphedNode;\n\t}\n\t\n\tmodule.exports = morphdom;\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 087cb910d95cf533c9ef\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar render = require('./render');\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: render.create,\n  render: render.render\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*! (C) WebReflection Mit Style License */\n(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error(\"A \"+n+\" type is already registered\");if(!m.test(p)||-1<S.call(g,p))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[c]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/document-register-element/build/document-register-element.js\n ** module id = 1\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render').create;\n\nvar RENDER = '__render';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        console.log('attached!', this);\n        this.update();\n      }},\n\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      render: {value: function(data) {\n        if (!arguments.length) data = this.data;\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      invalidate: {value: function() {\n        this[RENDER] = null;\n        this.render();\n      }},\n\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function property(read, write, value) {\n  return {\n    enumerable: false,\n\n    get: function() {\n      return read ? read.call(this, value) : value;\n    },\n\n    set: function(v) {\n      if (v !== value) {\n        var previous = value;\n        return value = write.call(this, v, previous);\n      }\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 3\n ** module chunks = 0\n **/","var arrow = require('./arrow');\nvar functor = require('./functor');\n\nvar evaluate = function(expression, data) {\n  var fn = evaluator(expression);\n  return fn.call(this, data);\n};\n\nvar evaluator = function(expression) {\n  if (typeof expression !== 'string') {\n    expression = String(expression);\n  }\n\n  if (!expression.trim()) {\n    return functor(undefined);\n  }\n\n  if (arrow.is(expression)) {\n    return arrow.parse(expression);\n  }\n\n  var symbol = 'd';\n  // '.' is just the identity function\n  if (expression.match(/^\\s*\\.\\s*$/)) {\n    return identity;\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    '  with (this) {',\n    '    with (', symbol, ') {',\n    '      return (', expression, ');',\n    '    } ',\n    '  } ',\n    '} catch (error) { }'\n  ].join('\\n'));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator,\n};\n\nfunction identity(d) {\n  return d;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 4\n ** module chunks = 0\n **/","var ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = match[4] || match[5];\n  return new Function(args, [\n    'try {',\n    '  with (this) {',\n    '    return (', body, ');',\n    '  }',\n    '} catch (error) { }'\n  ].join('\\n'));\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = function functor(x) {\n  return function f() {\n    return x;\n  }\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/functor.js\n ** module id = 6\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar functor = require('./functor');\nvar xp = require('./evaluate');\nvar interpolate = require('./interpolate');\nvar h = require('./h');\n\nvar morphdom = require('morphdom');\n\nvar ns = require('./ns');\n\n// our attribute namespace\nvar T_NS = 't-';\n\nvar T_AS = T_NS + 'as';\nvar T_EACH = T_NS + 'each';\nvar T_ELSE = T_NS + 'else';\nvar T_FOREACH = T_NS + 'foreach';\nvar T_IF = T_NS + 'if';\nvar T_SKIP = T_NS + 'skip';\nvar T_TEXT = T_NS + 'text';\nvar T_WITH = T_NS + 'with';\n\nvar CONTROL_ATTRS = [\n  'as',\n  'each',\n  'else',\n  'foreach',\n  'if',\n  'skip',\n  'text',\n  'with'\n];\n\nvar createRenderer = function(src, context) {\n  if (typeof src === 'string') {\n    var selector = src;\n    src = document.querySelector(src);\n    if (!src) {\n      throw new Error('no element found with selector: \"' + selector + '\"');\n    }\n  }\n\n  var render = compile(src);\n  return function(node, data) {\n    if (arguments.length < 2) {\n      data = node;\n    }\n    if ((!node && data) || node === data) {\n      node = src;\n    }\n    var dest = render.call(context || this, data);\n    // console.log('morphing:', src.outerHTML, '->', dest.outerHTML);\n    return morphdom(src, dest);\n  }\n};\n\nvar render = function(src, data, context) {\n  var render = createRenderer(src, context);\n  if (data) {\n    render(src, data);\n  }\n  return render;\n};\n\nvar compile = function(node) {\n  switch (node.nodeType) {\n    case 1: // Node.ELEMENT_NODE\n      return createElementRenderer(node);\n    case 3: // Node.TEXT_NODE\n      return createTextRenderer(node);\n\n    // TODO: support document fragments?\n    // this would need support in h()\n\n    default:\n      throw new Error('no renderer for node type: ' + node.nodeType);\n  }\n};\n\nmodule.exports.render = render;\nmodule.exports.createRenderer = createRenderer;\nmodule.exports.compile = compile;\n\nfunction compileExpression(expr) {\n  return interpolate.isTemplate(expr)\n    ? interpolate.compile(expr)\n    : code.evaluator(expr);\n}\n\nfunction createTextRenderer(node) {\n  return stringify(interpolate.compile(node.nodeValue));\n}\n\nfunction createElementRenderer(node) {\n  // this element will never be rendered if it has a truthy t-skip attribute\n  if (node.hasAttribute(T_SKIP)) {\n    return noop;\n  }\n\n  var name = node.nodeName.toLowerCase();\n  var attrMap = getAttributeMap(node);\n\n  var condition = node.hasAttribute(T_IF)\n    ? xp.evaluator(node.getAttribute(T_IF))\n    : undefined;\n\n  if (node.hasAttribute(T_ELSE)) {\n    if (condition) {\n      throw new Error('element has both t-if and t-else attributes');\n    }\n    var ifSibling = getPreviousSibling(node, '[' + T_IF + ']');\n    if (!ifSibling) {\n      throw new Error('element with t-else has no matching t-if sibling');\n    }\n    condition = not(xp.evaluator(ifSibling.getAttribute(T_IF)));\n  }\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  if (node.hasAttribute(T_TEXT)) {\n    renderChildren = stringify(\n      compileExpression(node.getAttribute(T_TEXT))\n    );\n  } else {\n    var childRenderers = [].map.call(node.childNodes, compile);\n    renderChildren = function(data) {\n      return childRenderers.map(function(renderChild) {\n        return renderChild.call(this, data);\n      }, this);\n    };\n  }\n\n  var renderNode = function(data) {\n    // console.log('rendering', node, 'with data:', data);\n    if (condition && !condition.call(this, data)) {\n      return undefined;\n    }\n\n    var attrs = interpolateAttributes.call(this, attrMap, data);\n    var children = renderChildren.call(this, data);\n    return h(name, attrs, children);\n  };\n\n  var eachExpression = node.getAttribute(T_EACH);\n  var forEachExpression = node.getAttribute(T_FOREACH);\n  var withExpression = node.getAttribute(T_WITH);\n\n  var symbol = node.getAttribute(T_AS);\n\n  if (eachExpression) {\n    renderNode = renderEach(eachExpression, renderNode, symbol);\n  } else if (forEachExpression) {\n    renderChildren = renderEach(forEachExpression, renderChildren, symbol);\n  } else if (withExpression) {\n    renderNode = renderWith(withExpression, renderNode, symbol);\n  } else if (symbol) {\n    renderNode = symbolSetter(symbol, renderNode);\n  }\n\n  return renderNode;\n}\n\nfunction renderEach(expression, render, symbol) {\n  var expr = xp.evaluator(expression);\n  return function(data) {\n    var values = expr.call(this, data);\n    return forEach.call(this, values, render, symbol);\n  };\n}\n\nfunction renderWith(expression, render, symbol) {\n  var expr = xp.evaluator(expression);\n  render = symbolSetter(symbol, render);\n  return function(data) {\n    data = expr.call(this, data);\n    return render.call(this, data);\n  };\n}\n\nfunction getAttributeMap(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = ns.qualify(attr.name);\n    var localName = name.localName;\n    var value = attr.value;\n    if (localName.indexOf(T_NS) === 0) {\n      localName = localName.substr(T_NS.length);\n      if (CONTROL_ATTRS.indexOf(localName) > -1) {\n        continue;\n      }\n      value = compileExpression(value);\n    }\n    var qname = name.prefix\n      ? name.prefix + ':' + localName\n      : localName;\n    map[qname] = value;\n  }\n  return map;\n}\n\nfunction interpolateAttributes(attrMap, data) {\n  var attrs = {};\n  for (var key in attrMap) {\n    var value = attrMap[key];\n    // only apply functions for attrs that aren't event handlers\n    if (typeof value === 'function' && key.indexOf('on') !== 0) {\n      value = value.call(this, data, key);\n    }\n    if (defined(value)) {\n      attrs[key] = value;\n    }\n  }\n  return attrs;\n}\n\nfunction getPreviousSibling(node, selector) {\n  while (node = node.previousSibling) {\n    if (!node) break;\n    // FIXME this needs a vendor prefix in IE 9+\n    // <http://caniuse.com/#search=matches>\n    if (node.matches(selector)) return node;\n  }\n  throw new Error('no previous sibling found matching: ' + selector);\n}\n\nfunction isElementVoid(name) {\n  return VOID_ELEMENTS.indexOf(name) > -1;\n}\n\nfunction forEach(data, fn, symbol) {\n  var previous;\n  var iterate = symbol\n    ? symbolSetter(symbol, fn)\n    : fn;\n\n  var result = [];\n  var INDEX = '$i';\n  var each = function(d, i) {\n    this[INDEX] = i;\n    result.push(iterate.call(this, d));\n    delete this[INDEX];\n  };\n\n  if (typeof data === 'object') {\n    if (Array.isArray(data)) {\n      data.forEach(each, this);\n    } else {\n      var i = 0;\n      for (var key in data) {\n        if (data.hasOwnProperty(key)) {\n          each.call(this, {key: key, value: data[key]}, i++);\n        }\n      }\n    }\n  } else if (typeof data === 'string') {\n    data.split('').forEach(each, this);\n  }\n\n  return result;\n}\n\nfunction symbolSetter(symbol, fn) {\n  return function(data) {\n    var previous = set(this, symbol, data);\n    var result = fn.call(this, data);\n    set(this, symbol, previous);\n    return result;\n  };\n}\n\nfunction defined(value) {\n  return value !== null && value !== undefined;\n}\n\nfunction not(fn) {\n  return function() {\n    return !fn.apply(this, arguments);\n  };\n}\n\nfunction set(context, symbol, value) {\n  var previous = context[symbol];\n  if (value === undefined) {\n    delete context[symbol];\n  } else {\n    context[symbol] = value;\n  }\n  return previous;\n}\n\nfunction stringify(fn) {\n  return function() {\n    var value = fn.apply(this, arguments);\n    return defined(value) ? String(value) : '';\n  };\n}\n\nfunction noop() {\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 7\n ** module chunks = 0\n **/","var evaluate = require('./evaluate').evaluate;\nvar functor = require('./functor');\n\nvar pattern = /{{\\s*([^}]+)\\s*}}/g;\n\nvar isTemplate = function(str) {\n  return new RegExp(pattern).test(str);\n};\n\nvar compile = function(template) {\n  if (typeof template !== 'string') {\n    throw new Error('interpolate.compile() expected a string;' +\n                    'got ' + (typeof template));\n  }\n\n  if (!isTemplate(template)) {\n    return functor(template);\n  }\n\n  return function(data) {\n    var that = this;\n    return template.replace(pattern, function(_, part) {\n      return evaluate.call(that, part, data);\n    });\n  };\n};\n\nvar interpolate = function interpolate(str, data) {\n  return compile(str).call(this, data);\n};\n\nmodule.exports = interpolate;\n\nmodule.exports.isTemplate = isTemplate;\n\nmodule.exports.compile = compile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/interpolate.js\n ** module id = 8\n ** module chunks = 0\n **/","var ns = require('./ns');\n\nmodule.exports = function(name, props, children) {\n  var node;\n  if (Array.isArray(name)) {\n    node = document.createDocumentFragment();\n  } else {\n    name = ns.qualify(name);\n    node = name.namespaceURI\n      ? document.createElementNS(name.namespaceURI, name.localName)\n      : document.createElement(name.localName);\n  }\n\n  if (Array.isArray(props) || typeof props === 'string') {\n    children = props;\n  } else if (typeof props === 'object') {\n    setProps(node, props);\n  }\n\n  var append = function(child) {\n    if (Array.isArray(child)) {\n      child.forEach(append);\n    } else if (typeof child === 'object') {\n      node.appendChild(child);\n    } else if (typeof child === 'string') {\n      node.appendChild(document.createTextNode(child));\n    }\n  };\n\n  if (typeof children === 'object' || typeof children === 'string') {\n    append(children);\n  }\n\n  return node;\n};\n\nvar setProps = function(el, props) {\n  for (var prop in props) {\n    var value = props[prop];\n    if (value === null || value === undefined || typeof value === 'function') {\n      // XXX: don't add null, undefined, or function values\n      continue;\n    } else if (typeof value === 'object') {\n      switch (prop) {\n        case 'class':\n          value = formatClassName(value);\n          break;\n\n        case 'style':\n          value = formatStyle(value);\n          break;\n\n        default:\n          console.warn('unrecognized object prop:', prop, value);\n          continue;\n      }\n    }\n\n    var name = ns.qualify(prop);\n    if (name.namespaceURI) {\n      el.setAttributeNS(name.namespaceURI, name.name, value);\n    } else {\n      el.setAttribute(name.localName, value);\n    }\n  }\n};\n\nvar formatStyle = function(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join('; ');\n  }\n  return Object.keys(obj)\n    .map(function(key) {\n      return [\n        reformatCamelCase(key),\n        ': ',\n        obj[key],\n        ';'\n      ].join('');\n    })\n    .join(' ');\n};\n\nvar reformatCamelCase = function(str) {\n  return str.replace(/[A-Z]/g, function(char) {\n    return '-' + char.toLowerCase();\n  });\n};\n\nvar formatClassName = function(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n  return Object.keys(obj).filter(function(key) {\n    return !!obj[key];\n  }).join(' ');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/h.js\n ** module id = 9\n ** module chunks = 0\n **/","var prefixToURI = {\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/TR/xlink/',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\nvar uriToPrefix = {};\nObject.keys(prefixToURI).forEach(function(prefix) {\n  uriToPrefix[prefixToURI[prefix]] = prefix;\n});\n\nvar qualify = function(qname) {\n  var prefix;\n  var localName = qname;\n  var colon = qname.indexOf(':');\n  if (colon > -1) {\n    prefix = qname.substr(0, colon);\n    localName = qname.substr(colon + 1);\n  }\n  return {\n    name: qname,\n    localName: localName,\n    prefix: prefix,\n    namespaceURI: prefixToURI[prefix]\n  };\n};\n\nmodule.exports = {\n  prefixToURI: prefixToURI,\n  uriToPrefix: uriToPrefix,\n  qualify: qualify\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ns.js\n ** module id = 10\n ** module chunks = 0\n **/","// Create a range object for efficently rendering strings to elements.\nvar range;\n\nvar testEl = typeof document !== 'undefined' ? document.body || document.createElement('div') : {};\n\n// Fixes https://github.com/patrick-steele-idem/morphdom/issues/32 (IE7+ support)\n// <=IE7 does not support el.hasAttribute(name)\nvar hasAttribute;\nif (testEl.hasAttribute) {\n    hasAttribute = function hasAttribute(el, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    hasAttribute = function hasAttribute(el, name) {\n        return el.getAttributeNode(name);\n    };\n}\n\nfunction empty(o) {\n    for (var k in o) {\n        if (o.hasOwnProperty(k)) {\n            return false;\n        }\n    }\n\n    return true;\n}\nfunction toElement(str) {\n    if (!range && document.createRange) {\n        range = document.createRange();\n        range.selectNode(document.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = document.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think\n     * that \"selected\" is an attribute when reading\n     * over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        if ((fromEl.selected = toEl.selected)) {\n            fromEl.setAttribute('selected', '');\n        } else {\n            fromEl.removeAttribute('selected', '');\n        }\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element\n     * since it sets the initial value. Changing the \"value\"\n     * attribute without changing the \"value\" property will have\n     * no effect since it is only used to the set the initial value.\n     * Similar for the \"checked\" attribute.\n     */\n    INPUT: function(fromEl, toEl) {\n        fromEl.checked = toEl.checked;\n\n        if (fromEl.value != toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttribute(toEl, 'checked')) {\n            fromEl.removeAttribute('checked');\n        }\n\n        if (!hasAttribute(toEl, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value != newValue) {\n            fromEl.value = newValue;\n        }\n\n        if (fromEl.firstChild) {\n            fromEl.firstChild.nodeValue = newValue;\n        }\n    }\n};\n\nfunction noop() {}\n\n/**\n * Loop over all of the attributes on the target node and make sure the\n * original DOM node has the same attributes. If an attribute\n * found on the original node is not on the new node then remove it from\n * the original node\n * @param  {HTMLElement} fromNode\n * @param  {HTMLElement} toNode\n */\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrValue;\n    var foundAttrs = {};\n\n    for (i=attrs.length-1; i>=0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrValue = attr.value;\n            foundAttrs[attrName] = true;\n\n            if (fromNode.getAttribute(attrName) !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Delete any extra attributes found on the original DOM element that weren't\n    // found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i=attrs.length-1; i>=0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            if (!foundAttrs.hasOwnProperty(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while(curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdom(fromNode, toNode, options) {\n    if (!options) {\n        options = {};\n    }\n\n    if (typeof toNode === 'string') {\n        if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n            var toNodeHtml = toNode;\n            toNode = document.createElement('html');\n            toNode.innerHTML = toNodeHtml;\n        } else {\n            toNode = toElement(toNode);\n        }\n    }\n\n    var savedEls = {}; // Used to save off DOM elements with IDs\n    var unmatchedEls = {};\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || options.onBeforeMorphEl || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || options.onBeforeMorphElChildren || noop;\n    var childrenOnly = options.childrenOnly === true;\n    var movedEls = [];\n\n    function removeNodeHelper(node, nestedInSavedEl) {\n        var id = getNodeKey(node);\n        // If the node has an ID then save it off since we will want\n        // to reuse it in case the target DOM tree has a DOM element\n        // with the same ID\n        if (id) {\n            savedEls[id] = node;\n        } else if (!nestedInSavedEl) {\n            // If we are not nested in a saved element then we know that this node has been\n            // completely discarded and will not exist in the final DOM.\n            onNodeDiscarded(node);\n        }\n\n        if (node.nodeType === 1) {\n            var curChild = node.firstChild;\n            while(curChild) {\n                removeNodeHelper(curChild, nestedInSavedEl || id);\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function walkDiscardedChildNodes(node) {\n        if (node.nodeType === 1) {\n            var curChild = node.firstChild;\n            while(curChild) {\n\n\n                if (!getNodeKey(curChild)) {\n                    // We only want to handle nodes that don't have an ID to avoid double\n                    // walking the same saved element.\n\n                    onNodeDiscarded(curChild);\n\n                    // Walk recursively\n                    walkDiscardedChildNodes(curChild);\n                }\n\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function removeNode(node, parentNode, alreadyVisited) {\n        if (onBeforeNodeDiscarded(node) === false) {\n            return;\n        }\n\n        parentNode.removeChild(node);\n        if (alreadyVisited) {\n            if (!getNodeKey(node)) {\n                onNodeDiscarded(node);\n                walkDiscardedChildNodes(node);\n            }\n        } else {\n            removeNodeHelper(node);\n        }\n    }\n\n    function morphEl(fromEl, toEl, alreadyVisited, childrenOnly) {\n        var toElKey = getNodeKey(toEl);\n        if (toElKey) {\n            // If an element with an ID is being morphed then it is will be in the final\n            // DOM so clear it out of the saved elements collection\n            delete savedEls[toElKey];\n        }\n\n        if (!childrenOnly) {\n            if (onBeforeElUpdated(fromEl, toEl) === false) {\n                return;\n            }\n\n            morphAttrs(fromEl, toEl);\n            onElUpdated(fromEl);\n\n            if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                return;\n            }\n        }\n\n        if (fromEl.tagName != 'TEXTAREA') {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeId;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var savedEl;\n            var unmatchedEl;\n\n            outer: while(curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeId = getNodeKey(curToNodeChild);\n\n                while(curFromNodeChild) {\n                    var curFromNodeId = getNodeKey(curFromNodeChild);\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (!alreadyVisited) {\n                        if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {\n                            unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);\n                            morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);\n                            curFromNodeChild = fromNextSibling;\n                            continue;\n                        }\n                    }\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        var isCompatible = false;\n\n                        if (curFromNodeType === 1) { // Both nodes being compared are Element nodes\n                            if (curFromNodeChild.tagName === curToNodeChild.tagName) {\n                                // We have compatible DOM elements\n                                if (curFromNodeId || curToNodeId) {\n                                    // If either DOM element has an ID then we handle\n                                    // those differently since we want to match up\n                                    // by ID\n                                    if (curToNodeId === curFromNodeId) {\n                                        isCompatible = true;\n                                    }\n                                } else {\n                                    isCompatible = true;\n                                }\n                            }\n\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform the current \"from\" node\n                                // to match the current target DOM node.\n                                morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);\n                            }\n                        } else if (curFromNodeType === 3) { // Both nodes being compared are Text nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to change the text value\n                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                        }\n\n                        if (isCompatible) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying\n                    // to find a match in the original DOM\n                    removeNode(curFromNodeChild, fromEl, alreadyVisited);\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                if (curToNodeId) {\n                    if ((savedEl = savedEls[curToNodeId])) {\n                        morphEl(savedEl, curToNodeChild, true);\n                        curToNodeChild = savedEl; // We want to append the saved element instead\n                    } else {\n                        // The current DOM element in the target tree has an ID\n                        // but we did not find a match in any of the corresponding\n                        // siblings. We just put the target element in the old DOM tree\n                        // but if we later find an element in the old DOM tree that has\n                        // a matching ID then we will replace the target element\n                        // with the corresponding old element and morph the old element\n                        unmatchedEls[curToNodeId] = curToNodeChild;\n                    }\n                }\n\n                // If we got this far then we did not find a candidate match for our \"to node\"\n                // and we exhausted all of the children \"from\" nodes. Therefore, we will just\n                // append the current \"to node\" to the end\n                if (onBeforeNodeAdded(curToNodeChild) !== false) {\n                    fromEl.appendChild(curToNodeChild);\n                    onNodeAdded(curToNodeChild);\n                }\n\n                if (curToNodeChild.nodeType === 1 && (curToNodeId || curToNodeChild.firstChild)) {\n                    // The element that was just added to the original DOM may have\n                    // some nested elements with a key/ID that needs to be matched up\n                    // with other elements. We'll add the element to a list so that we\n                    // can later process the nested elements if there are any unmatched\n                    // keyed elements that were discarded\n                    movedEls.push(curToNodeChild);\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            // We have processed all of the \"to nodes\". If curFromNodeChild is non-null then\n            // we still have some from nodes left over that need to be removed\n            while(curFromNodeChild) {\n                fromNextSibling = curFromNodeChild.nextSibling;\n                removeNode(curFromNodeChild, fromEl, alreadyVisited);\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        var specialElHandler = specialElHandlers[fromEl.tagName];\n        if (specialElHandler) {\n            specialElHandler(fromEl, toEl);\n        }\n    } // END: morphEl(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n        // Handle the case where we are given two DOM nodes that are not\n        // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n        if (morphedNodeType === 1) {\n            if (toNodeType === 1) {\n                if (fromNode.tagName !== toNode.tagName) {\n                    onNodeDiscarded(fromNode);\n                    morphedNode = moveChildren(fromNode, document.createElement(toNode.tagName));\n                }\n            } else {\n                // Going from an element node to a text node\n                morphedNode = toNode;\n            }\n        } else if (morphedNodeType === 3) { // Text node\n            if (toNodeType === 3) {\n                morphedNode.nodeValue = toNode.nodeValue;\n                return morphedNode;\n            } else {\n                // Text node to something else\n                morphedNode = toNode;\n            }\n        }\n    }\n\n    if (morphedNode === toNode) {\n        // The \"to node\" was not compatible with the \"from node\"\n        // so we had to toss out the \"from node\" and use the \"to node\"\n        onNodeDiscarded(fromNode);\n    } else {\n        morphEl(morphedNode, toNode, false, childrenOnly);\n\n        /**\n         * What we will do here is walk the tree for the DOM element\n         * that was moved from the target DOM tree to the original\n         * DOM tree and we will look for keyed elements that could\n         * be matched to keyed elements that were earlier discarded.\n         * If we find a match then we will move the saved element\n         * into the final DOM tree\n         */\n        var handleMovedEl = function(el) {\n            var curChild = el.firstChild;\n            while(curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var savedEl = savedEls[key];\n                    if (savedEl && (curChild.tagName === savedEl.tagName)) {\n                        curChild.parentNode.replaceChild(savedEl, curChild);\n                        morphEl(savedEl, curChild, true /* already visited the saved el tree */);\n                        curChild = nextSibling;\n                        if (empty(savedEls)) {\n                            return false;\n                        }\n                        continue;\n                    }\n                }\n\n                if (curChild.nodeType === 1) {\n                    handleMovedEl(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        };\n\n        // The loop below is used to possibly match up any discarded\n        // elements in the original DOM tree with elemenets from the\n        // target tree that were moved over without visiting their\n        // children\n        if (!empty(savedEls)) {\n            handleMovedElsLoop:\n            while (movedEls.length) {\n                var movedElsTemp = movedEls;\n                movedEls = [];\n                for (var i=0; i<movedElsTemp.length; i++) {\n                    if (handleMovedEl(movedElsTemp[i]) === false) {\n                        // There are no more unmatched elements so completely end\n                        // the loop\n                        break handleMovedElsLoop;\n                    }\n                }\n            }\n        }\n\n        // Fire the \"onNodeDiscarded\" event for any saved elements\n        // that never found a new home in the morphed DOM\n        for (var savedElId in savedEls) {\n            if (savedEls.hasOwnProperty(savedElId)) {\n                var savedEl = savedEls[savedElId];\n                onNodeDiscarded(savedEl);\n                walkDiscardedChildNodes(savedEl);\n            }\n        }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n        // If we had to swap out the from node with a new node because the old\n        // node was not compatible with the target node then we need to\n        // replace the old DOM node in the original DOM tree. This is only\n        // possible if the original DOM node was part of a DOM tree which\n        // we know is the case if it has a parent node.\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n}\n\nmodule.exports = morphdom;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/morphdom/lib/index.js\n ** module id = 11\n ** module chunks = 0\n **/"],"sourceRoot":""}